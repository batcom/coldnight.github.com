<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>cold's world</title><link href="http://www.linuxzen.com/" rel="alternate"></link><link href="http://www.linuxzen.com/feeds/python.atom.xml" rel="self"></link><id>http://www.linuxzen.com/</id><updated>2013-05-30T09:50:00+08:00</updated><entry><title>Pual 更新支持SimSimi可以进行互动</title><link href="http://www.linuxzen.com/pual-geng-xin-zhi-chi-simsimike-yi-jin-xing-hu-dong.html" rel="alternate"></link><updated>2013-05-30T09:50:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-05-30:pual-geng-xin-zhi-chi-simsimike-yi-jin-xing-hu-dong.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.linuxzen.com/jie-yong-tornadoshi-xian-gao-xiao-de-webqqji-qi-ren.html"&gt;Pual&lt;/a&gt; 跑了许久, 通过一段时间的修改现在Pual主要支持以下功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英汉互译&lt;/li&gt;
&lt;li&gt;为每个用户分配一个session的含有上下文的Python shell&lt;/li&gt;
&lt;li&gt;贴代码&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;总而言之就是一个被动型的辅助机器人, 群里有同学建议&lt;code&gt;AI&lt;/code&gt;功能, 但是我水平不够没办法设计和实现&lt;code&gt;AI&lt;/code&gt;部分, 所以想调用&lt;code&gt;SimSimi&lt;/code&gt;实现&lt;code&gt;AI&lt;/code&gt;, 发现官方Key才免费7天, 我这等穷苦人如何是买不起key的, google发现有一个非官方API可以调用, 但是被封了.但咱不是个容易放弃的人, 经过一番折腾非官方API可以正常调用, 所以Pual也有&lt;code&gt;AI&lt;/code&gt;功能了, 只要在有Pual的群里发送&lt;code&gt;Pual&lt;/code&gt;打头的消息 就可以和&lt;code&gt;Pual&lt;/code&gt;互动&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coldnight/pual_bot"&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pual帐号是:1685359365, 大家可以先加好友回答验证问题:cold, 然后将它拉入群内进行调戏&lt;/p&gt;</summary><category term="Pual"></category><category term="Python"></category><category term="bot"></category><category term="SimSimi"></category></entry><entry><title>说说Python装饰器</title><link href="http://www.linuxzen.com/shuo-shuo-pythonzhuang-shi-qi.html" rel="alternate"></link><updated>2013-05-20T14:52:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-05-20:shuo-shuo-pythonzhuang-shi-qi.html</id><summary type="html">&lt;p&gt;装饰器对与Python新手以至于熟悉Python的人都是一个难理解, 难写的东西. 那么今天就分享一下我对Python 装饰器的理解&lt;/p&gt;
&lt;p&gt;所谓装饰器仅仅是一种语法糖, 可作用的对象可以是函数也可以是类, 装饰器本身是一个函数, 其主要工作方式就是将被装饰的类或者函数当作参数传递给装饰器函数, 比如定义如下装饰器&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;import time

def run_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        r = func(*args, **kwargs)
        print time.time() - start
        return r
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用这个装饰器装饰一个&lt;code&gt;test&lt;/code&gt;函数&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;@run_time
def test():
    print &amp;quot;just a test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面说过其实装饰器就是一个语法糖, 就是将被装饰的函数作为参数传递给装饰器函数, 所以上面可以展开为&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;test = run_time(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器将在解释器运行一开始就被加载, 从而将被装饰的函数将被展开成如上方式, 因为 &lt;code&gt;run_time&lt;/code&gt;装饰器返回&lt;code&gt;wrapper&lt;/code&gt;函数, 所以当调用&lt;code&gt;test&lt;/code&gt;函数时其实就是对&lt;code&gt;wrapper&lt;/code&gt;的调用&lt;/p&gt;
&lt;p&gt;如果你在Python shell下执行以上语句就会发现定义完&lt;code&gt;test&lt;/code&gt;函数然后查看&lt;code&gt;test&lt;/code&gt;时, shell所展示的是wrapper函数:
&lt;a href="http://www.linuxzen.com"&gt;&lt;img alt="说说Python装饰器" src="/static/upload/pyshell.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;接下来说说如何编写带参数的装饰器, 大家如果细心的话就可以发现其实带参数的装饰器是经过调用"装饰器"函数返回的一个装饰器, 之所以装饰器上打引号是说明其实这个所谓的"装饰器"只不过是一个普通的函数, 但这个普通的函数返回一个装饰器, 可以参看下面例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;import time

def route(url):
    def decorator(func):
        func.__url__ = url
        return func
    return decorator

@route(r&amp;quot;/&amp;quot;)
def index():
    return &amp;quot;Hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家可以发现在使用&lt;code&gt;route&lt;/code&gt;装饰器时我们其实是调用了&lt;code&gt;route&lt;/code&gt;函数, &lt;code&gt;route&lt;/code&gt;函数返回一个&lt;code&gt;decorator&lt;/code&gt;装饰器, 因为我们不需要在装饰器内运行函数, 所以不需要一个&lt;code&gt;wrapper&lt;/code&gt;函数来收集参数.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;以上就是全部内容, 希望对装饰器一知半解的人有些许帮助&lt;/p&gt;</summary><category term="Python"></category><category term="装饰器"></category></entry><entry><title>clubot更新: 使用SQLAlchemy重写数据库部分和改用Tornado MainLoop</title><link href="http://www.linuxzen.com/clubotgeng-xin-shi-yong-sqlalchemyzhong-xie-shu-ju-ku-bu-fen-he-gai-yong-tornado-mainloop.html" rel="alternate"></link><updated>2013-04-26T15:40:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-04-26:clubotgeng-xin-shi-yong-sqlalchemyzhong-xie-shu-ju-ku-bu-fen-he-gai-yong-tornado-mainloop.html</id><summary type="html">&lt;p&gt;&lt;a href="/python-shi-yong-pyxmpp2bian-xie-gtalkqun.html"&gt;clubot&lt;/a&gt;在我的vps上跑了有一段时间了, 最近接触了&lt;code&gt;SQLAlchemy&lt;/code&gt; 然后反观&lt;code&gt;clubot&lt;/code&gt;的数据库代码部分, 感觉代码又遭有乱实在看不过眼, 所以就使用&lt;code&gt;SQLAlchemy&lt;/code&gt;重写了数据库模块, 并将&lt;code&gt;epoll&lt;/code&gt;的MainLoop改成&lt;a href="http://lilydjwg.is-programmer.com/"&gt;仙子君&lt;/a&gt;所写的&lt;a href="https://github.com/lilydjwg/pyxmpp2"&gt;TornadoMainLoop&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;更新内容&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;数据库使用&lt;code&gt;SQLAlchemy&lt;/code&gt;重写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MainLoop&lt;/code&gt;改用&lt;code&gt;TornadoMainLoop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改变代码结构, 清理部分代码&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;history&lt;/code&gt;命令改为&lt;code&gt;old&lt;/code&gt;, 并支持时间查询&lt;/li&gt;
&lt;li&gt;废弃一些不常用的命令&lt;/li&gt;
&lt;li&gt;改变数据库表结构&lt;/li&gt;
&lt;li&gt;废弃&lt;code&gt;channel&lt;/code&gt;功能, &lt;code&gt;cd&lt;/code&gt;命令仅支持切换聊天和安静模式&lt;/li&gt;
&lt;li&gt;删除一些不用的配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如何升级&lt;/h2&gt;
&lt;p&gt;数据库表结构做了更改, 所以为了兼容之前的数据库本次表名前加上&lt;code&gt;clubot_&lt;/code&gt;前缀, 并配以&lt;code&gt;update.py&lt;/code&gt;脚本用以支持将旧的数据导入.&lt;/p&gt;
&lt;h2&gt;新的依赖&lt;/h2&gt;
&lt;p&gt;本次更新添加了依赖, 现在依赖包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pyxmpp2&lt;/li&gt;
&lt;li&gt;dnspython&lt;/li&gt;
&lt;li&gt;tornado&lt;/li&gt;
&lt;li&gt;sqlalchemy&lt;/li&gt;
&lt;li&gt;MySQL-python&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;乱码&lt;/h2&gt;
&lt;p&gt;如果数据导入后乱码, 可以参考&lt;a href="/sqlalchemy-mysqlshu-ju-ku-luan-ma-jie-jue.html"&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;项目地址&lt;/h2&gt;
&lt;p&gt;最后放上&lt;a href="https://github.com/coldnight/clubot"&gt;项目地址&lt;/a&gt;&lt;/p&gt;</summary><category term="clubot"></category><category term="pyxmpp2"></category><category term="gtalk"></category><category term="xmpp"></category><category term="更新"></category><category term="重写"></category><category term="SQLAlchemy"></category><category term="tornado"></category></entry><entry><title>SQLAlchemy MySQL数据库乱码解决</title><link href="http://www.linuxzen.com/sqlalchemy-mysqlshu-ju-ku-luan-ma-jie-jue.html" rel="alternate"></link><updated>2013-04-26T00:00:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-04-26:sqlalchemy-mysqlshu-ju-ku-luan-ma-jie-jue.html</id><summary type="html">&lt;p&gt;今天对&lt;a href="/python-shi-yong-pyxmpp2bian-xie-gtalkqun.html"&gt;clubot&lt;/a&gt;进行了&lt;a href="/clubotgeng-xin-shi-yong-sqlalchemyzhong-xie-shu-ju-ku-bu-fen-he-gai-yong-tornado-mainloop.html"&gt;升级&lt;/a&gt;, 但是导入数据后中文乱码, 一开是找资料说是在创建引擎的时候添加编码信息:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;engine = create_engine(&amp;quot;mysql://root:@localhost:3306/clubot?charset=utf8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这并不行, 然后查看表信息:&lt;/p&gt;
&lt;pre&gt;&lt;code class="mysql"&gt;&amp;gt; show create table clubot_members;
clubot_members | CREATE TABLE `clubot_members` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(100) DEFAULT NULL,
  `nick` varchar(50) DEFAULT NULL,
  `last_say` timestamp NULL DEFAULT NULL,
  `last_change` timestamp NULL DEFAULT NULL,
  `isonline` int(11) DEFAULT NULL,
  `join_date` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`),
  UNIQUE KEY `nick` (`nick`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=latin1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现原来创建表的时候用的&lt;code&gt;latin1&lt;/code&gt;编码, 而老的表是用&lt;code&gt;utf-8&lt;/code&gt;编码创建的, &lt;code&gt;SQLAlchemy&lt;/code&gt;中并没有发现有创建表时指定指定编码的方法. 所以只能在&lt;code&gt;MySQL&lt;/code&gt;本身来找:&lt;/p&gt;
&lt;pre&gt;&lt;code class="mysql"&gt;&amp;gt; show VARIABLES like &amp;quot;character%%&amp;quot;;
+--------------------------+-----------------------------+
| Variable_name            | Value                       |
+--------------------------+-----------------------------+
| character_set_client     | utf8                        |
| character_set_connection | utf8                        |
| character_set_database   | latin1                      |
| character_set_filesystem | binary                      |
| character_set_results    | utf8                        |
| character_set_server     | latin1                      |
| character_set_system     | utf8                        |
| character_sets_dir       | /data/share/mysql/charsets/ |
+--------------------------+-----------------------------+
8 rows in set (0.00 sec)

&amp;gt; show create database clubot;
+----------+-------------------------------------------------------------------+
| Database | Create Database                                                   |
+----------+-------------------------------------------------------------------+
| clubot   | CREATE DATABASE `clubot` /*!40100 DEFAULT CHARACTER SET latin1 */ |
+----------+-------------------------------------------------------------------+
1 row in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现 &lt;code&gt;MySQL&lt;/code&gt;默认的和数据库都是&lt;code&gt;latin1&lt;/code&gt;的编码, 所以更改数据库配置&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;vi /etc/mysql/my.cnf      # MySQL配置文件在Ubuntu上的位置, 其他系统可能有差异
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别在&lt;code&gt;[client]&lt;/code&gt; &lt;code&gt;[mysqld]&lt;/code&gt;下添加&lt;/p&gt;
&lt;pre&gt;&lt;code class="conf"&gt;default-character-set = utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时重启MySQL居然起不来, 说&lt;code&gt;default-character-set&lt;/code&gt;是无效的变量, 查看&lt;code&gt;MySQL&lt;/code&gt;版本发现是5.5, 找资料说5.5的服务端编码设置变量是&lt;code&gt;character-set-server&lt;/code&gt;, 所以将&lt;code&gt;[mysqld]&lt;/code&gt;上的&lt;code&gt;default-character-set = utf8&lt;/code&gt;改为 &lt;code&gt;character-set-server = utf8&lt;/code&gt;, 并重启&lt;code&gt;MySQL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后更改数据库编码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="mysql"&gt;alter database clubot character set utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除新建的表, 并重新导入数据中文就正常了&lt;/p&gt;
&lt;pre&gt;&lt;code class="mysql"&gt;&amp;gt; use clubot;
&amp;gt; drop table clubot_status;
&amp;gt; drop table clubot_infos;
&amp;gt; drop table clubot_history;
&amp;gt; drop table clubot_members;
&lt;/code&gt;&lt;/pre&gt;</summary><category term="sqlalchemy"></category><category term="MySQL"></category><category term="数据库"></category><category term="乱码"></category><category term="utf8"></category></entry><entry><title>借用Tornado实现高效的WebQQ机器人</title><link href="http://www.linuxzen.com/jie-yong-tornadoshi-xian-gao-xiao-de-webqqji-qi-ren.html" rel="alternate"></link><updated>2013-04-23T13:36:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-04-23:jie-yong-tornadoshi-xian-gao-xiao-de-webqqji-qi-ren.html</id><summary type="html">&lt;p&gt;之前有写过一篇文章介绍使用&lt;code&gt;Pyxmpp2&lt;/code&gt;桥接QQ和xmpp的文章(&lt;a href="/shi-yong-webqqxie-yi-qiao-jie-xmpphe-qqqun.html"&gt;这里&lt;/a&gt;).后来我打算将WebQQ单独出来运行, 一开始直接拷贝了&lt;code&gt;pyxmpp2&lt;/code&gt;的mainloop, 但是跑起来问题多多, 所以我又研究了利用&lt;code&gt;Tornado&lt;/code&gt;进行网络编程(&lt;a href="/shi-yong-tornadojin-xing-wang-luo-yi-bu-bian-cheng.html"&gt;这里&lt;/a&gt;), 所以我放弃了&lt;code&gt;Pyxmpp2&lt;/code&gt;的mainloop,使用&lt;code&gt;Tornado&lt;/code&gt;进行重写&lt;/p&gt;
&lt;p&gt;首先放出&lt;a href="https://github.com/coldnight/pual_bot"&gt;项目代码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;WebQQ协议是一套基于&lt;code&gt;HTTP&lt;/code&gt;的QQ协议, 而用&lt;code&gt;Python&lt;/code&gt;的&lt;code&gt;urllib2&lt;/code&gt;库进行请求太慢, 因为HTTP本身就使用socket请求, 所以改用多路复用I/O模型, 而&lt;code&gt;Tornado&lt;/code&gt;简单高效, 看过代码后可以轻松上手.平台兼容性很好, 所以选择&lt;code&gt;Tornado&lt;/code&gt;作为网络框架.&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;首先实现了一个 &lt;code&gt;HTTPStream&lt;/code&gt;类, 其主要接口是&lt;code&gt;add_request&lt;/code&gt;方法, 它接受一个必选参数:&lt;code&gt;request&lt;/code&gt; 是一个 &lt;code&gt;urllib2.Request&lt;/code&gt;的实例, 和一个可选参数:&lt;code&gt;readback&lt;/code&gt;是一个接受一个&lt;code&gt;urllib2.urlopen(request)&lt;/code&gt;返回的&lt;code&gt;Response&lt;/code&gt;参数的读取函数, 代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;class HTTPStream(object):
    # 省略若干代码
    def add_request(self, request, readback = None):
        if not isinstance(request, urllib2.Request):
            raise ValueError, &amp;quot;Not a invaid requset&amp;quot;

        # 此处易触发timeout异常, 省略处理异常代码
        sock, data = self.http_sock.make_http_sock_data(request)

        fd = sock.fileno()
        self.fd_map[fd] = sock
        self.fd_request_map[fd] = request
        callback = partial(self._handle_events, request, data, readback)
        self.ioloop.add_handler(fd, callback, IOLoop.WRITE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HTTPStream.add_request&lt;/code&gt;将&lt;code&gt;urllib2.Request&lt;/code&gt;的实例解析出一个&lt;code&gt;socket&lt;/code&gt;和一个用于&lt;code&gt;socket&lt;/code&gt;发送的数据.前面文章介绍过了, &lt;code&gt;tornado.ioloop.IOLoop.add_handler&lt;/code&gt;用于将注册socket, 其需要三个参数: socket的文件描述符, 接受文件描述符和事件参数的回调, 和注册的事件.&lt;/p&gt;
&lt;p&gt;我们用到的回调是&lt;code&gt;HTTPStream._handle_events&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;class HTTPStream(object):
    # 省略若干代码
    def _handle_events(self, request, data, readback, fd, event):
        &amp;quot;&amp;quot;&amp;quot; 用于处理Tornado事件
        Arguments:
            `request`   -   urllib.Request
            `data`      -   socket要写入的数据
            `readback`  -   读取函数
            以上参数应当使用partial封装然后将此方法作为IOLoop.add_handler的callback
            `fd`        -   IOLoop传递 文件描述符
            `event`     -   IOLoop传递 tornado
        &amp;quot;&amp;quot;&amp;quot;
        s = self.fd_map[fd]

        if event &amp;amp; IOLoop.READ:
            # 省略错误处理
            resp = self.http_sock.make_response(s, request)
            args = readback(resp)
            s.setblocking(False)
            if args and len(args) == 3:
                t = threading.Thread(target = self.add_delay_request, args = args)
                t.setDaemon(True)
                t.start()

            if args and len(args) == 2:
                self.add_request(*args)
            self.ioloop.remove_handler(fd)

        if event &amp;amp; IOLoop.WRITE:
            s.sendall(data)
            if readback:
                self.ioloop.update_handler(fd, IOLoop.READ)
            else:
                self.ioloop.remove_handler(fd)

        if event &amp;amp; IOLoop.ERROR:
            pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它接受的参数上面注释写的很清楚, 不做解释, 所以将此方法通过&lt;code&gt;functools.partial&lt;/code&gt;封装做为&lt;code&gt;callback&lt;/code&gt;传递给&lt;code&gt;tornado.ioloop.IOLoop.add_handler&lt;/code&gt;, 并注册为&lt;code&gt;写&lt;/code&gt;事件, 以便发送&lt;code&gt;HTTP&lt;/code&gt;请求.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTPStream._handle_events&lt;/code&gt;用于处理事件, 当事件为写时就发送&lt;code&gt;HTTP&lt;/code&gt;请求(根据&lt;code&gt;urllib2.Request&lt;/code&gt;生成的用于发送的数据), 并判断是否有读取函数, 有则注册&lt;code&gt;读&lt;/code&gt;事件, 当事件为读时就从socket中构建一个&lt;code&gt;Response&lt;/code&gt;并传递给读取函数, 读取函数会返回3个值, 分别为: 下一个请求, 请求的读取函数(可为None, 为None则只请求不读取), 下一个请求的延迟(多长事件后添加此请求, 可选, 单位为秒)&lt;/p&gt;
&lt;p&gt;依据读取函数返回的三个值来确定下一个请求, 并完成一系列的请求. 更加完整的代码请参见文章开头给出的项目代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTPStream.http_sock.make_response&lt;/code&gt;执行时会将&lt;code&gt;socket&lt;/code&gt;设为阻塞, 因为不设置阻塞会出现&lt;code&gt;httplib.BadStatusLine&lt;/code&gt;异常.读取函数执行完毕,重新将&lt;code&gt;socket&lt;/code&gt;设置为非阻塞, 并移除此&lt;code&gt;socket&lt;/code&gt;(虽然做了这样的处理但是QQ连接时间稍长还是会触发&lt;code&gt;httplib.BadStatusLine&lt;/code&gt;异常)&lt;/p&gt;
&lt;h2&gt;2013-04-26 更新&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;解决 在线时间稍长, 当经过多次请求后会触发&lt;code&gt;socket.gaierror(-2, 'Name or service not known')&lt;/code&gt; 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;存在问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;没有重试机制&lt;/li&gt;
&lt;/ol&gt;</summary><category term="tornado"></category><category term="高效"></category><category term="webqq"></category><category term="并发"></category><category term="协议"></category></entry><entry><title>使用Pelican打造静态博客</title><link href="http://www.linuxzen.com/shi-yong-pelicanda-zao-jing-tai-bo-ke.html" rel="alternate"></link><updated>2013-04-18T09:40:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-04-18:shi-yong-pelicanda-zao-jing-tai-bo-ke.html</id><summary type="html">&lt;p&gt;前面有文章介绍本站采用了&lt;code&gt;Python&lt;/code&gt;编写的&lt;code&gt;Pelican&lt;/code&gt;静态生成博客系统, 之所以没有使用当前很火的&lt;code&gt;Jekyll&lt;/code&gt;, 是因为它是&lt;code&gt;Ruby&lt;/code&gt;编写, 而我又对&lt;code&gt;Ruby&lt;/code&gt;没有啥兴趣, 所以还是选择了使用了我熟悉的Python编写的这套系统, 我用了一段时间,打算将使用经验分享出来&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pelican&lt;/code&gt;是一套开源的使用Python编写的博客静态生成, 可以添加文章和和创建页面, 可以使用&lt;code&gt;MarkDown&lt;/code&gt; &lt;code&gt;reStructuredText&lt;/code&gt; 和 &lt;code&gt;AsiiDoc&lt;/code&gt; 的格式来抒写, 同时使用 &lt;code&gt;Disqus&lt;/code&gt;评论系统, 支持 &lt;code&gt;RSS&lt;/code&gt;和&lt;code&gt;Atom&lt;/code&gt;输出, 插件, 主题, 代码高亮等功能, 采用&lt;code&gt;Jajin2&lt;/code&gt;模板引擎, 可以很容易的更改模板&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;可以从&lt;code&gt;github&lt;/code&gt;克隆最新的代码安装, 并且建议在&lt;code&gt;virtualenv&lt;/code&gt;下使用:&lt;/p&gt;
&lt;h3&gt;建立 virtualenv&lt;/h3&gt;
&lt;pre&gt;&lt;code class="bash"&gt;virtualenv pelican      # 创建
cd pelican
sh bin/activate            # 激活虚拟环境
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面建立了一个Python的虚拟环境(这个命令不是内置可以使用 &lt;code&gt;easy_install virtualenv&lt;/code&gt; 安装)&lt;/p&gt;
&lt;h3&gt;从github克隆最新代码安装Pelican&lt;/h3&gt;
&lt;pre&gt;&lt;code class="bash"&gt;git clone git://github.com/getpelican/pelican.git            # 代码
cd pelican
python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面步骤完成后就安装了Pelican&lt;/p&gt;
&lt;h2&gt;开始一个博客&lt;/h2&gt;
&lt;pre&gt;&lt;code class="bash"&gt;mkdir /path/to/your/blog
cd /path/to/your/blog
pelican-quickstart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在回答一系列问题过后你的博客就建成的, 主要生成下列文件:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;.
|-- content                # 所有文章放于此目录
|-- develop_server.sh      # 用于开启测试服务器
|-- Makefile               # 方便管理博客的Makefile
|-- output                 # 静态生成文件
|-- pelicanconf.py         # 配置文件
|-- publishconf.py         # 配置文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;写一篇文章&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;content&lt;/code&gt; 目录新建一个 &lt;code&gt;test.md&lt;/code&gt;文件, 填入一下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class="md"&gt;Title: 文章标题
Date: 2013-04-18
Category: 文章类别
Tag: 标签1, 标签2

这里是内容
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;make html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用以生成html&lt;/p&gt;
&lt;p&gt;然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;./develop_server.sh start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启一个测试服务器, 这会在本地 8000 端口建立一个测试web服务器, 可以使用浏览器打开:&lt;code&gt;http://localhost:8000&lt;/code&gt;来访问这个测试服务器, 然后就可以欣赏到你的博客了&lt;/p&gt;
&lt;h3&gt;创建一个页面&lt;/h3&gt;
&lt;p&gt;这里以创建 &lt;code&gt;About&lt;/code&gt;页面为例&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;content&lt;/code&gt;目录创建&lt;code&gt;pages&lt;/code&gt;目录&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;mkdir content/pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后创建&lt;code&gt;About.md&lt;/code&gt;并填入下面内容&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;Title: About Me
Date: 2013-04-18

About me content
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行 &lt;code&gt;make html&lt;/code&gt; 生成html, 然后打开 &lt;code&gt;http://localhost:8000&lt;/code&gt;查看效果&lt;/p&gt;
&lt;h3&gt;让Pelican支持评论&lt;/h3&gt;
&lt;p&gt;Pelican 使用&lt;code&gt;Disqus&lt;/code&gt;评论, 可以申请在&lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt;上申请一个站点, 然后在&lt;code&gt;pelicanconf.py&lt;/code&gt;里添加或修改&lt;code&gt;DISQUS_SITENAME&lt;/code&gt;项:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;DISQUS_SITENAME = u&amp;quot;linuxzen&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;make html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器打开 &lt;code&gt;http://localhost:8000&lt;/code&gt;查看效果&lt;/p&gt;
&lt;h3&gt;更换主题&lt;/h3&gt;
&lt;p&gt;Pelican本身也提供了一些主题可供选择, 可以从github克隆下来&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;git clone git://github.com/getpelican/pelican-themes.git     # 主题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在里面找到想要的主题, 然后拷到博客项目当前目录, 这里已&lt;code&gt;neat&lt;/code&gt;为例&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;cp -r /path/to/themes/from/github/neat .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;pelicanconf.py&lt;/code&gt; 配置文件里添加或修改 &lt;code&gt;THEME&lt;/code&gt;项为 &lt;code&gt;neat&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;THEME = &amp;quot;neat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新执行 &lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;make html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开 &lt;code&gt;http://localhost:8000&lt;/code&gt; 查看效果&lt;/p&gt;
&lt;h3&gt;使用插件&lt;/h3&gt;
&lt;p&gt;Pelican 一开始是将插件内置的, 但是新版本 Pelican将插件隔离了出来, 所以我们要到github上 克隆一份新的插件, 在博客目录执行&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;git clone git://github.com/getpelican/pelican-plugins.git    # 插件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们博客目录就新添了一个 &lt;code&gt;pelican-plugins&lt;/code&gt;目录, 我们已配置&lt;code&gt;sitemap&lt;/code&gt;插件为例,
&lt;code&gt;sitemap&lt;/code&gt;插件可以生成 &lt;code&gt;sitemap.xml&lt;/code&gt; 供搜索引擎使用&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;pelicanconf.py&lt;/code&gt;配置文件里加上如下项:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;PLUGIN_PATH = u&amp;quot;pelican-plugins&amp;quot;

PLUGINS = [&amp;quot;sitemap&amp;quot;]

## 配置sitemap 插件
SITEMAP = {
    &amp;quot;format&amp;quot;: &amp;quot;xml&amp;quot;,
    &amp;quot;priorities&amp;quot;: {
        &amp;quot;articles&amp;quot;: 0.7,
        &amp;quot;indexes&amp;quot;: 0.5,
        &amp;quot;pages&amp;quot;: 0.3,
    },
    &amp;quot;changefreqs&amp;quot;: {
        &amp;quot;articles&amp;quot;: &amp;quot;monthly&amp;quot;,
        &amp;quot;indexes&amp;quot;: &amp;quot;daily&amp;quot;,
        &amp;quot;pages&amp;quot;: &amp;quot;monthly&amp;quot;,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再执行&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;make html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器请求 &lt;code&gt;http://localhost:8000/sitemap.xml&lt;/code&gt;即可看到生成的 Sitemap 了&lt;/p&gt;
&lt;h3&gt;拷贝静态文件&lt;/h3&gt;
&lt;p&gt;如果我们定义静态的文件, 该如何将它在每次生成的时候拷贝到 output 目录呢, 我们以&lt;code&gt;robots.txt&lt;/code&gt; 为例, 在我们的 content/extra 下面我们放了一个定义好的 &lt;code&gt;robots.txt&lt;/code&gt;文件, 在&lt;code&gt;pelicanconf.py&lt;/code&gt;更改或添加 &lt;code&gt;FILES_TO_COPY&lt;/code&gt;项:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;FILES_TO_COPY = (
    (&amp;quot;extra/robots.txt&amp;quot;, &amp;quot;robots.txt&amp;quot;),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在每次生成html的时候都会把 &lt;code&gt;content/extra&lt;/code&gt;下的 &lt;code&gt;robots.txt&lt;/code&gt; 拷贝到 &lt;code&gt;output&lt;/code&gt;目录下&lt;/p&gt;
&lt;h3&gt;拷贝静态目录&lt;/h3&gt;
&lt;p&gt;如果是一个静目录怎么办? 我们可以在&lt;code&gt;pelicanconf.py&lt;/code&gt;里添加或修改 &lt;code&gt;STATIC_PATHS&lt;/code&gt;项, 比如我们有个&lt;code&gt;img&lt;/code&gt;目录用来放文章所使用的图片, 我们可以在&lt;code&gt;pelicanconf.py&lt;/code&gt;添加&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;STATIC_PATHS = [u&amp;quot;img&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行 &lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;make html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 Pelican 就会将 &lt;code&gt;img&lt;/code&gt;目录拷贝到 &lt;code&gt;output/static/&lt;/code&gt; 下&lt;/p&gt;
&lt;h2&gt;部署&lt;/h2&gt;
&lt;p&gt;上面都弄完之后你就可以得到一个功能健全的博客系统, 接下来就是部署到服务器, 上传到服务器并结合nginx或者apache等web服务器部署这里就不在详述&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;如果还有其他问题请参考&lt;a href="http://docs.getpelican.com/"&gt;官方手册&lt;/a&gt;&lt;/p&gt;</summary><category term="Python"></category><category term="静态"></category><category term="生成"></category><category term="Pelican"></category><category term="博客"></category></entry><entry><title>使用Tornado进行网络异步编程</title><link href="http://www.linuxzen.com/shi-yong-tornadojin-xing-wang-luo-yi-bu-bian-cheng.html" rel="alternate"></link><updated>2013-04-15T16:09:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-04-15:shi-yong-tornadojin-xing-wang-luo-yi-bu-bian-cheng.html</id><summary type="html">&lt;h2&gt;Tornado&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Tornado&lt;/code&gt; 是一款非阻塞可扩展的使用Python编写的web服务器和Python Web框架, 可以使用&lt;code&gt;Tornado&lt;/code&gt;编写Web程序并不依赖任何web服务器直接提供高效的web服务.所以&lt;code&gt;Tornado&lt;/code&gt;不仅仅是一个web框架而且还是一款可以用于生产环境的高效的web服务器&lt;/p&gt;
&lt;p&gt;Torando 在Linux和FreeBSD上使用高效的异步I/O模型 &lt;code&gt;epoll&lt;/code&gt; 和&lt;code&gt;kqueue&lt;/code&gt;来实现高效的web服务器, 所以 tornado在Linux上和FreeBSD系列性能可以达到最高&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;当然我们可以不仅仅把&lt;code&gt;Tornado&lt;/code&gt;看作是一个web框架和web服务器, 我们可以利用&lt;code&gt;Tornado&lt;/code&gt;提供的接口进行高效的网络异步编程,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tornado.ioloop.IOLoop&lt;/code&gt; 提供了三个接口可以用于网络编程:&lt;/p&gt;
&lt;h3&gt;add_handler&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;def add_handler(self, fd, handler, events):
    self._handlers[fd] = stack_context.wrap(handler)
    self._impl.register(fd, events | self.ERROR)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;add_handler&lt;/code&gt;用于添加socket到主循环中, 接受三个参数:
&lt;em&gt; fd 是socket的文件描述符
&lt;/em&gt; handler 是处理此socket的 callback函数
* events 是此socket注册的事件&lt;/p&gt;
&lt;h3&gt;update_handler&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;def update_handler(self, fd, events):
    self._impl.modify(fd, events | self.ERROR)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;update_handler&lt;/code&gt;用于更新住循环中已存在的socket响应事件, 接受两个参数:
&lt;em&gt; fd 是socket对应的文件描述符
&lt;/em&gt; events 是注册的新事件&lt;/p&gt;
&lt;h3&gt;remove_handler&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;def remove_handler(self, fd):
    self._handlers.pop(fd, None)
    self._events.pop(fd, None)
    try:
        self._impl.unregister(fd)
    except Exception:
        gen_log.debug(&amp;quot;Error deleting fd from IOLoop&amp;quot;, exc_info=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remove_handler&lt;/code&gt;用于移除主循环中已存在的socket&lt;/p&gt;
&lt;h2&gt;事件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tornado.ioloop.IOLoop&lt;/code&gt;同时提供了4种响应事件:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;tornado.ioloop.IOLoop.NONE&lt;/td&gt;
&lt;td&gt;无事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tornado.ioloop.IOLoop.READ&lt;/td&gt;
&lt;td&gt;读事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tornado.ioloop.IOLoop.WRITE&lt;/td&gt;
&lt;td&gt;写事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tornado.ioloop.IOLoop.ERROR&lt;/td&gt;
&lt;td&gt;发生错误的事件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;实例&lt;/h2&gt;
&lt;p&gt;根据上面的接口和事件我们就可以写出一个简单的 echo server&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
#   Author  :   cold
#   E-mail  :   wh_linux@126.com
#   Date    :   13/04/15 15:08:51
#   Desc    :   Tornado Echo Server
#   HOME    :   http://www.linuxzen.com
#
import Queue
import socket

from functools import partial

from tornado.ioloop import IOLoop

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setblocking(0)              # 将socket设置为非阻塞

server_address = (&amp;quot;localhost&amp;quot;, 10000)

sock.bind(server_address)
sock.listen(5)

fd_map = {}              # 文件描述符到socket的映射
message_queue_map = {}   # socket到消息队列的映射

fd = sock.fileno()
fd_map[fd] = sock

ioloop = IOLoop.instance()

def handle_client(cli_addr, fd, event):
    s = fd_map[fd]
    if event &amp;amp; IOLoop.READ:
        data = s.recv(1024)
        if data:
            print &amp;quot;     received '%s' from %s&amp;quot; % (data, cli_addr)
            # 接收到消息更改事件为写, 用于发送数据到对端
            ioloop.update_handler(fd, IOLoop.WRITE)
            message_queue_map[s].put(data)
        else:
            print &amp;quot;     closing %s&amp;quot; % cli_addr
            ioloop.remove_handler(fd)
            s.close()
            del message_queue_map[s]

    if event &amp;amp; IOLoop.WRITE:
        try:
            next_msg = message_queue_map[s].get_nowait()
        except Queue.Empty:
            print &amp;quot;%s queue empty&amp;quot; % cli_addr
            ioloop.update_handler(fd, IOLoop.READ)
        else:
            print 'sending &amp;quot;%s&amp;quot; to %s' % (next_msg, cli_addr)
            s.send(next_msg)

    if event &amp;amp; IOLoop.ERROR:
        print &amp;quot; exception on %s&amp;quot; % cli_addr
        ioloop.remove_handler(fd)
        s.close()
        del message_queue_map[s]


def handle_server(fd, event):
    s = fd_map[fd]
    if event &amp;amp; IOLoop.READ:
        conn, cli_addr = s.accept()
        print &amp;quot;     connection %s&amp;quot; % cli_addr[0]
        conn.setblocking(0)
        conn_fd = conn.fileno()
        fd_map[conn_fd] = conn
        handle = partial(handle_client, cli_addr[0])   # 将cli_addr作为第一个参数
        # 将连接和handle注册为读事件加入到 tornado ioloop
        ioloop.add_handler(conn_fd, handle, IOLoop.READ)
        message_queue_map[conn] = Queue.Queue()   # 创建对应的消息队列


ioloop.add_handler(fd, handle_server, IOLoop.READ)

ioloop.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码就建立了一个非阻塞的高效的异步的echo server&lt;/p&gt;</summary><category term="Python"></category><category term="tornado"></category><category term="网络"></category><category term="异步"></category><category term="编程"></category></entry><entry><title>使用WebQQ协议桥接XMPP和QQ群</title><link href="http://www.linuxzen.com/shi-yong-webqqxie-yi-qiao-jie-xmpphe-qqqun.html" rel="alternate"></link><updated>2013-03-14T16:09:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-03-14:shi-yong-webqqxie-yi-qiao-jie-xmpphe-qqqun.html</id><summary type="html">&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;无意中看见有人利用WebQQ协议开发出Linux下Pidgin的插件, 让Pidgin来收发QQ消息, 突然想将&lt;a href="/python-shi-yong-pyxmpp2bian-xie-gtalkqun.html"&gt;clubot&lt;/a&gt;和QQ群来桥接起来一定非常有趣,这样就可以通过gtalk收发QQ来的消息, 不过前期还是想将&lt;code&gt;clubot&lt;/code&gt;和QQ群桥接起来.&lt;/p&gt;
&lt;h2&gt;实施&lt;/h2&gt;
&lt;p&gt;想到了就开始弄呗, 于是上网找了写有关WebQQ的协议, 首先写出了一个根据&lt;code&gt;urllib2&lt;/code&gt;的版本并使用线程同时跑WebQQ和xmpp, 源码可以查看:
&lt;a href="https://github.com/coldnight/qxbot/tree/threading_version"&gt;thread_version&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;优化&lt;/h2&gt;
&lt;p&gt;上面的线程版效率不是很高, 由于都是网络请求, 所以想加入可以加入到pyxmpp2的mainloop中, 使用复用I/O模型来提高效率, 首先需要解决的是将http请求通过urllib2改为socket, 于是写出HTTPSock类来实现这个需求:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
#   Author  :   Wood.D
#   E-mail  :   wh_linux@126.com
#   Date    :   13/03/04 09:58:26
#   Desc    :   Http Socket 实现
#
import ssl
import socket
import urllib
import urllib2
import httplib
import urlparse
import tempfile
import cookielib
from lib.utils import Form

class HTTPSock(object):
    &amp;quot;&amp;quot;&amp;quot; 构建支持Cookie的HTTP socket
    供可复用的I/O模型调用&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        cookiefile = tempfile.mktemp()
        self.cookiejar = cookielib.MozillaCookieJar(cookiefile)

    def make_request(self, url, form, method = &amp;quot;GET&amp;quot;):
        &amp;quot;&amp;quot;&amp;quot; 根据url 参数 构建 urllib2.Request &amp;quot;&amp;quot;&amp;quot;
        request = urllib2.Request(url)
        if isinstance(form, Form):
            request.add_header(&amp;quot;Content-Type&amp;quot;, form.get_content_type())
            request.add_header(&amp;quot;Content-Length&amp;quot;, len(str(form)))
            request.add_data(str(form))
        elif isinstance(form, (dict, list, tuple)):
            params = urllib.urlencode(form)
            if method == &amp;quot;GET&amp;quot;:
                url = &amp;quot;{0}?{1}&amp;quot;.format(url, params)
                request = urllib2.Request(url)
            else:
                request = urllib2.Request(url, params)
                request.add_header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)

        self.cookiejar.add_cookie_header(request)
        request.headers.update(request.unredirected_hdrs)
        return request

    def make_response(self, sock, req, method):
        &amp;quot;&amp;quot;&amp;quot; 根据socket和urlib2.Request 构建Response &amp;quot;&amp;quot;&amp;quot;
        r = httplib.HTTPResponse(sock, 0, strict = 0, method = method, buffering=True)
        r.begin()

        r.recv = r.read
        fp = socket._fileobject(r, close=True)

        resp = urllib.addinfourl(fp, r.msg, req.get_full_url())
        resp.code = r.status
        resp.msg = r.reason
        self.cookiejar.extract_cookies(resp, req)
        self.cookiejar.save()
        return resp


    def make_http_sock_data(self, request):
        &amp;quot;&amp;quot;&amp;quot; 根据urllib2.Request 构建socket和用于发送的HTTP源数据 &amp;quot;&amp;quot;&amp;quot;
        url = request.get_full_url()
        headers = request.headers
        data = request.get_data()
        parse = urlparse.urlparse(url)
        host, port = urllib.splitport(parse.netloc)
        typ = parse.scheme
        port = port if port else getattr(httplib, typ.upper() + &amp;quot;_PORT&amp;quot;)
        data =  self.get_http_source(parse, data, headers)
        if hasattr(self, &amp;quot;do_&amp;quot; + typ):
            return getattr(self, &amp;quot;do_&amp;quot;+typ)(host, port), data

    def do_http(self, host, port):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(3)
        sock.connect((host, int(port)))
        sock.setblocking(0)
        return sock

    def do_https(self, host, port, keyfile = None, certfile = None):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(3)
        sock.connect((host, int(port)))
        sock = ssl.wrap_socket(sock, keyfile, certfile)
        sock.setblocking(0)
        return sock

    def get_http_source(self, parse, data, headers):
        path = parse.path
        query = parse.query
        path = path + &amp;quot;?&amp;quot; + query if query else path
        path = path if path else &amp;quot;/&amp;quot;
        method = &amp;quot;POST&amp;quot; if data else &amp;quot;GET&amp;quot;
        _buffer= [&amp;quot;{0} {1} HTTP/1.1&amp;quot;.format(method, path)]
        e_headers = [(k.lower(), v) for k, v in headers.items()]
        headers = []
        headers.append((&amp;quot;Host&amp;quot;, parse.netloc))
        headers.append((&amp;quot;Connection&amp;quot;, &amp;quot;keep-alive&amp;quot;))
        headers.append((&amp;quot;Accept&amp;quot;, &amp;quot;*/*&amp;quot;))
        headers.append((&amp;quot;Accept-Charset&amp;quot;, &amp;quot;UTF-8,*;q=0.5&amp;quot;))
        headers.append((&amp;quot;Accept-Encoding&amp;quot;, &amp;quot;gzip,deflate,sdch&amp;quot;))
        headers.append((&amp;quot;Accept-Language&amp;quot;, &amp;quot;zh-CN,zh;q=0.8&amp;quot;))
        headers.append((&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0 (X11; Linux x86_64)&amp;quot;\
                        &amp;quot; AppleWebKit/537.11 (KHTML, like Gecko)&amp;quot;\
                        &amp;quot; Chrome/23.0.1271.97 Safari/537.11&amp;quot;))
        headers+= e_headers
        if data:
            headers.append((&amp;quot;Content-Length&amp;quot;,   len(data)))
        for key, value in headers:
            _buffer.append(&amp;quot;{0}: {1}&amp;quot;.format(key.title(), value))
        _buffer.extend((&amp;quot;&amp;quot;, &amp;quot;&amp;quot;))
        result = &amp;quot;\r\n&amp;quot;.join(_buffer)
        if isinstance(data, str):
            result += data
        return result

    @property
    def cookie(self):
        return self.cookiejar._cookies
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是根据&lt;code&gt;urllib2.Request&lt;/code&gt;构建socket和socket要发送的数据, 然后将socket返回的数据构建成&lt;code&gt;response&lt;/code&gt;, 然后编写一些handlers来加入到mainloop中去,优化后的版本:
&lt;a href="https://github.com/coldnight/qxbot/tree/master"&gt;epoll_version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个版本使用了epoll作为主循环, 更加高效.&lt;/p&gt;
&lt;h2&gt;最新版本&lt;/h2&gt;
&lt;p&gt;最新版本分离了WebQQ作为一个包, 如仅需WebQQ的功能可以很方便的分离出来(当然要仿照pyxmpp2来实现一套事件机制), 源码:
&lt;a href="https://github.com/coldnight/qxbot/"&gt;last&lt;/a&gt;&lt;/p&gt;</summary><category term="WebQQ"></category><category term="xmpp"></category><category term="python"></category><category term="XMPP"></category><category term="pyxmpp2"></category></entry><entry><title>使用Pelican博客静态生成系统</title><link href="http://www.linuxzen.com/shi-yong-pelicanbo-ke-jing-tai-sheng-cheng-xi-tong.html" rel="alternate"></link><updated>2013-03-14T15:12:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-03-14:shi-yong-pelicanbo-ke-jing-tai-sheng-cheng-xi-tong.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;最近流行使用静态生成的博客, 看了很多感觉很棒总想尝试一下, 大名鼎鼎的&lt;code&gt;Jekyll&lt;/code&gt;使用ruby,看了很多文档介绍,依旧不能入门使用,也许是用Ruby编写,对它比较迟钝.看到了一款Python编写的静态生成系统&lt;code&gt;Pelican&lt;/code&gt;, 试用后除了模板较少外感觉还是不错的,使用&lt;code&gt;Markdown&lt;/code&gt;和&lt;code&gt;Rst&lt;/code&gt;编写.&lt;/p&gt;
&lt;h1&gt;安装&lt;/h1&gt;
&lt;p&gt;可以试用&lt;code&gt;pip&lt;/code&gt;来安装&lt;code&gt;Pelican&lt;/code&gt;, 通过&lt;code&gt;pelican-quickstart&lt;/code&gt;脚本可以快速构建一个站点,详细不在描述.可以看看它的文档&lt;/p&gt;
&lt;h2&gt;模板&lt;/h2&gt;
&lt;p&gt;模板采用&lt;code&gt;neat&lt;/code&gt;,这个模板设计简单(看我的页面就知道有多简单了)我非常喜欢, 但是有几个链接&lt;code&gt;bug&lt;/code&gt;,bug不是很难找,很轻松就能找出来, 这里不列出来, 基于这个模板我做了一点更改.&lt;/p&gt;
&lt;h1&gt;使用&lt;/h1&gt;
&lt;p&gt;在执行&lt;code&gt;pelican-quickstart&lt;/code&gt;是开启Makefile, 可以通过make很简单的生成html.&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;make html   # 生成html
make clean  # 删除output
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;技巧&lt;/h2&gt;
&lt;p&gt;我是将生成的html通过nginx来打开(Nginx配置就很简单了, 这里就不做介绍), 那么如何确保更新呢?我将整个博客上传到github, 这样随时随地可以&lt;code&gt;clone&lt;/code&gt;下来进行更改然后&lt;code&gt;push&lt;/code&gt;上去,在服务器我通过crontab来定时更新html&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;*/5 * * * * cd /path/to/your/blogsource/ &amp;amp;&amp;amp; git pull &amp;amp;&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以没5分钟更新一次&lt;/p&gt;</summary><category term="博客"></category><category term="Pelican"></category><category term="静态"></category><category term="迁移"></category></entry><entry><title>vLog 一个使用Python编写的轻量级博客系统</title><link href="http://www.linuxzen.com/vlog-ge-shi-yong-pythonbian-xie-de-qing-liang-ji-bo-ke-xi-tong.html" rel="alternate"></link><updated>2013-02-05T16:43:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-02-05:vlog-ge-shi-yong-pythonbian-xie-de-qing-liang-ji-bo-ke-xi-tong.html</id><summary type="html">&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3&gt;何为vLog&lt;/h3&gt;
&lt;p&gt;大家有人可能注意到博客改变了,是的前面也有文章提到从wordpress迁移到vlog,但是何为vLog这里给大家简要的说明一下,vLog是我使用&lt;code&gt;Python&lt;/code&gt;的&lt;code&gt;tornado&lt;/code&gt;框架和&lt;code&gt;Jinja2&lt;/code&gt;模板引擎,基于MySQL数据的一个轻量级的博客系统,此系统功能比较薄弱,处于开发初期,使用&lt;code&gt;Markdown&lt;/code&gt;的格式来抒写博文.&lt;/p&gt;
&lt;h3&gt;为什么vLog&lt;/h3&gt;
&lt;p&gt;vLog后台十分简单(可以说是简陋),功能也简单,就是一款简单的博客系统,提供了Python终端脚本,可以在终端来抒写博文, vLog使用一套非常简单的缓存系统,缓存使用memcached使得页面加载速度非常快.&lt;/p&gt;
&lt;h3&gt;为什么不vLog&lt;/h3&gt;
&lt;p&gt;相对与wordpress vlog非常简陋,仅仅提供简单的博客功能,而且使用Python编写主机方面支援不太多,虽然有&lt;code&gt;SAE&lt;/code&gt;和&lt;code&gt;GAE&lt;/code&gt;的支援,但是我没弄过,所以没有支援&lt;code&gt;SAE&lt;/code&gt;和&lt;code&gt;GAE&lt;/code&gt;(如果你有兴趣,可以添加相关支持)&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;h3&gt;平台&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;python2.7&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;Memcached 1.4.5&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;依赖库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;tornado&lt;/li&gt;
&lt;li&gt;jinja2&lt;/li&gt;
&lt;li&gt;MySQLdb&lt;/li&gt;
&lt;li&gt;pylibmc&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;开始安装&lt;/h3&gt;
&lt;p&gt;首先确认config.py的DEBUG是打开的,然后执行run.py,打开浏览器输入当前地址,会跳转到安装页面.按照提示安装,安装完毕后可以关闭DEBUG&lt;/p&gt;
&lt;h2&gt;从Wordpress中导入&lt;/h2&gt;
&lt;h3&gt;从Wordpress导出&lt;/h3&gt;
&lt;p&gt;在wordpress管理后台选择工具-&amp;gt;导出,下载导出文件可以导出一份xml&lt;/p&gt;
&lt;h3&gt;移动媒体文件&lt;/h3&gt;
&lt;p&gt;将/path/to/your/wordpress/wp-content/uploads/下的所有文件移动到/path/to/your/vlog/web/static/upload 下即可&lt;/p&gt;
&lt;p&gt;务必要先执行这一步然后再在后台里导入xml&lt;/p&gt;
&lt;h3&gt;导入到vLog&lt;/h3&gt;
&lt;p&gt;进入vLog后台,选择导入,浏览选中导出的xml, 然后选择开始,等待提示成功后即导入成功&lt;/p&gt;
&lt;h3&gt;手动更改没有生效的链接&lt;/h3&gt;
&lt;p&gt;虽然我已经竭尽所能的让你手头的工作更少,但是还不够,还是存在许多需要手动更改的地方,
比如每篇文章的没有替换掉的图片链接&lt;/p&gt;
&lt;h3&gt;不足&lt;/h3&gt;
&lt;p&gt;网站迁移后我已经尽力的来保持原来的链接有效,但是我仅仅知道我原来的wordpress的链接,所以仅仅兼容了我原来使用wordpress的旧链接,如果没能兼容您的wordpress的链接在此表示歉意,您可以自己添加提交给我,或者将您的链接提交给我由我来给您添加&lt;/p&gt;
&lt;h2&gt;结合nginx&lt;/h2&gt;
&lt;p&gt;参阅&lt;a href="http://www.tornadoweb.cn/documentation#_14"&gt;tornado文档&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;代码放在github上: &lt;a href="https://github.com/coldnight/vlog"&gt;vLog&lt;/a&gt;&lt;/p&gt;</summary><category term="vLog"></category><category term="tornado"></category><category term="blog"></category><category term="博客"></category><category term="轻量"></category><category term="markdown"></category></entry><entry><title>使用更加高效的epoll作为pyxmpp2的主循环</title><link href="http://www.linuxzen.com/shi-yong-geng-jia-gao-xiao-de-epollzuo-wei-pyxmpp2de-zhu-xun-huan.html" rel="alternate"></link><updated>2013-02-05T16:06:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-02-05:shi-yong-geng-jia-gao-xiao-de-epollzuo-wei-pyxmpp2de-zhu-xun-huan.html</id><summary type="html">&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;之前&lt;a href="/python-shi-yong-pyxmpp2bian-xie-gtalkqun.html"&gt;clubot&lt;/a&gt;使用的pyxmpp2的默认mainloop也就是一个poll的主循环,但是&lt;code&gt;clubot&lt;/code&gt;上线后资源占用非常厉害,使用&lt;code&gt;strace&lt;/code&gt;跟踪发现&lt;code&gt;clubot&lt;/code&gt;在不停的&lt;code&gt;poll&lt;/code&gt;,查看&lt;code&gt;pyxmpp2&lt;/code&gt;代码发现&lt;code&gt;pyxmpp2&lt;/code&gt;的&lt;code&gt;poll&lt;/code&gt;在使用超时阻塞时使用&lt;code&gt;最小&lt;/code&gt;超时时间,而&lt;code&gt;最小&lt;/code&gt;超时时间一直是0,所以会变成一个没有超时的非阻塞&lt;code&gt;poll&lt;/code&gt;很浪费资源,不打算更改库代码,所以自己仿照poll的mainloop写了一个更加高效的&lt;code&gt;epoll&lt;/code&gt;的mainloop&lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
#   Author  :   cold
#   E-mail  :   wh_linux@126.com
#   Date    :   13/01/06 10:41:31
#   Desc    :   Clubot epoll mainloop
#
from __future__ import absolute_import, division

import select

from pyxmpp2.mainloop.interfaces import HandlerReady, PrepareAgain
from pyxmpp2.mainloop.base import MainLoopBase

from plugin.util import get_logger



class EpollMainLoop(MainLoopBase):
    &amp;quot;&amp;quot;&amp;quot; Main event loop based on the epoll() syscall on Linux system &amp;quot;&amp;quot;&amp;quot;
    READ_ONLY = (select.EPOLLIN | select.EPOLLPRI | select.EPOLLHUP |
                 select.EPOLLERR |select.EPOLLET)
    READ_WRITE = READ_ONLY | select.EPOLLOUT
    def __init__(self, settings = None, handlers= None):
        self.epoll = select.epoll()
        self._handlers = {}
        self._unprepared_handlers = {}
        self._timeout = None
        self._exists_fd = {}
        self.logger = get_logger()
        MainLoopBase.__init__(self, settings, handlers)

        return

    def _add_io_handler(self, handler):
        self._unprepared_handlers[handler] = None
        self._configure_io_handler(handler)

    def _configure_io_handler(self, handler):
        if self.check_events():
            return
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            prepared = self._prepare_io_handler(handler)
        else:
            old_fileno = None
            prepared = True
        fileno = handler.fileno()
        if old_fileno is not None and fileno != old_fileno:
            del self._handlers[old_fileno]
            self._exists.pop(old_fileno, None)
            self.epoll.unregister(old_fileno)
        if not prepared:
            self._unprepared_handlers[handler] = fileno

        if not fileno:
            return

        self._handlers[fileno] = handler
        events = 0
        if handler.is_readable():
            events |= self.READ_ONLY
        if handler.is_writable():
            events |= self.READ_WRITE

        if events:
            if fileno in self._exists_fd:
                self.epoll.modify(fileno, events)
            else:
                self._exists_fd.update({fileno:1})
                self.epoll.register(fileno, events)

    def _prepare_io_handler(self, handler):
        ret = handler.prepare()
        if isinstance(ret, HandlerReady):
            del self._unprepared_handlers[handler]
            prepared = True
        elif isinstance(ret, PrepareAgain):
            if ret.timeout is not None:
                if self._timeout is not None:
                    self._timeout = min(self._timeout, ret.timeout)
                else:
                    self._timeout = ret.timeout
            prepared = False
        else:
            raise TypeError(&amp;quot;Unexpected result from prepare()&amp;quot;)

        return prepared

    def _remove_io_handler(self, handler):
        if handler in self._unprepared_handlers:
            old_fileno = self._unprepared_handlers[handler]
            del self._unprepared_handlers[handler]
        else:
            old_fileno = handler.fileno()
        if old_fileno is not None:
            try:
                del self._handlers[old_fileno]
                self._exists.pop(old_fileno, None)
                self.epoll.unregister(old_fileno)
            except KeyError:
                pass

    def loop_iteration(self, timeout = 60):
        next_timeout, sources_handled = self._call_timeout_handlers()
        if self.check_events():
            return
        if self._quit:
            return sources_handled
        for handler in list(self._unprepared_handlers):
            self._configure_io_handler(handler)
        if self._timeout is not None:
            timeout = min(timeout, self._timeout)
        if next_timeout is not None:
            timeout = min(next_timeout, timeout)

        if timeout == 0:
            timeout += 1    # 带有超时的非阻塞,解约资源
        events = self.epoll.poll(timeout)
        for fd, flag in events:
            if flag &amp;amp; (select.EPOLLIN | select.EPOLLPRI | select.EPOLLET):
                self._handlers[fd].handle_read()
            if flag &amp;amp; (select.EPOLLOUT|select.EPOLLET):
                self._handlers[fd].handle_write()
            if flag &amp;amp; (select.EPOLLERR | select.EPOLLET):
                self._handlers[fd].handle_err()
            if flag &amp;amp; (select.EPOLLHUP | select.EPOLLET):
                self._handlers[fd].handle_hup()
            #if flag &amp;amp; select.EPOLLNVAL:
                #self._handlers[fd].handle_nval()

            sources_handled += 1
            self._configure_io_handler(self._handlers[fd])

        return sources_handled
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;如何使用新的mainloop?只需在实例化Client时传入&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;mainloop = EpollMainLoop(settings)
client = Client(my_jid, [self, version_provider], settings, mainloop)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就会使用epoll作为mainloop&lt;/p&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;p&gt;epoll仅仅在&lt;code&gt;Linux&lt;/code&gt;下支持&lt;/p&gt;
&lt;h2&gt;写在后面的话&lt;/h2&gt;
&lt;p&gt;欢迎大家加入到&lt;code&gt;clubot@vim-cn.com&lt;/code&gt;中来讨论有关Python/vim/Linux/开源等话题&lt;/p&gt;</summary><category term="epoll"></category><category term="python"></category><category term="gtalk"></category><category term="群"></category><category term="Linux"></category><category term="clubot"></category></entry><entry><title>Python 重复安装包报错</title><link href="http://www.linuxzen.com/python-zhong-fu-an-zhuang-bao-bao-cuo.html" rel="alternate"></link><updated>2013-01-25T14:55:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-01-25:python-zhong-fu-an-zhuang-bao-bao-cuo.html</id><summary type="html">&lt;p&gt;最近写程序用到argparse总是会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/lib/python2.7/dist-packages/pygments/plugin.py:39: UserWarning: Module argparse was already imported from /usr/lib/python2.7/argparse.pyc, but /usr/local/lib/python2.7/dist-packages is being added to sys.path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一开始也没怎么在意,不影响什么,但是后来总是出来严重影响心情,google 了没啥明确的报错,后来仔细看报错信息,想起来以前可能庄过argparse这个包测试,但是没有删除
执行&lt;code&gt;ls /usr/local/lib/python2.7/dist-packages/&lt;/code&gt;查看果然有一个argparse.&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;sudo pip uninstall argparse&lt;/code&gt;烦人的错误提示消失了.&lt;/p&gt;</summary><category term="python"></category><category term="包"></category><category term="重复"></category><category term="安装"></category><category term="卸载"></category></entry><entry><title>Linux 下使用Python截图自动分享</title><link href="http://www.linuxzen.com/linux-xia-shi-yong-pythonjie-tu-zi-dong-fen-xiang.html" rel="alternate"></link><updated>2013-01-22T16:59:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-01-22:linux-xia-shi-yong-pythonjie-tu-zi-dong-fen-xiang.html</id><summary type="html">&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;Linux下不支持QQ等功能丰富的IM,虽然可以通过wine运行QQ2012,但是还是喜欢在gtalk群中聊天,gtalk群不支持图片方式,这就要靠我们大家自己来解决了,&lt;a href="http://eleveni386.7axu.com"&gt;eleven&lt;/a&gt;开放了一个Image上传和显示接口,提供了使用&lt;code&gt;curl&lt;/code&gt;来解决,但是我们公司的网络使用&lt;code&gt;squid&lt;/code&gt;禁止了&lt;code&gt;curl&lt;/code&gt;的访问,所以整天看他们这么爽的分享图片我也不甘心阿,所以就使用Python写了一个分享图片的脚本&lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;使用scrot截图,然后使用urllib2库上传图片,如果存在PyQt4库则会将结果放到剪贴板上,如果不存在则输出,自行复制&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
#   Author  :   cold
#   E-mail  :   wh_linux@126.com
#   Date    :   13/01/21 09:54:39
#   Desc    :   贴代码和图片
#
import urllib2, json
import mimetools
import mimetypes
import itertools

__host__ = &amp;quot;http://eleveni386.7axu.com&amp;quot;

class Form(object):
    def __init__(self):
        self.form_fields = []
        self.files = []
        self.boundary = mimetools.choose_boundary()
        self.content_type = &amp;quot;application/x-www-form-urlencoded&amp;quot;
        return

    def get_content_type(self):
        return self.content_type

    def add_field(self, name, value):
        self.form_fields.append((name, value))
        return

    def add_file(self, fieldname, filename, fileHandle, mimetype=None):
        body = fileHandle.read()
        if mimetype is None:
            mimetype = ( mimetypes.guess_type(filename)[0]
                         or
                         'applicatioin/octet-stream')
        self.files.append((fieldname, filename, mimetype, body))
        self.content_type = 'multipart/form-data; boundary=%s' % self.boundary

        return

    def __str__(self):
        parts = []
        part_boundary = '--' + self.boundary

        parts.extend(
            [ part_boundary,
             'Content-Disposition: form-data; name=&amp;quot;%s&amp;quot;' % name,
             '',
             value,
             ]
            for name, value in self.form_fields)
        if self.files:
            parts.extend([
                part_boundary,
                'Content-Disposition: form-data; name=&amp;quot;%s&amp;quot;; filename=&amp;quot;%s&amp;quot;' %\
                (field_name, filename),
                'Content-Type: %s' % content_type,
                '',
                body,
            ] for field_name, filename, content_type, body in self.files)

        flattened = list(itertools.chain(*parts))
        flattened.append('--' + self.boundary + '--')
        flattened.append('')
        return '\r\n'.join(flattened)


class HttpHelper(object):
    def __init__(self, url = None, form = None, method = 'GET'):
        self._url = url
        self._form = form
        self._body = str(form)
        self._method = method
        self._dst_url = None
        if url:
            self.make_request()

    def make_request(self):
        url = self._url
        if not self._url.startswith('http://'):
            url = 'http://' + self._url
        self.request = urllib2.Request(url)
        if self._form:
            self.add_header(&amp;quot;Content-Type&amp;quot;, self._form.get_content_type())
            self.add_header(&amp;quot;Content-Length&amp;quot;, len(self._body))
            self.request.add_data(self._body)

    def add_header(self, key, val):
        self.request.add_header(key, val)

    def change(self, url, params = {}, method = 'GET'):
        self._url = url
        self._params = params
        self._method = method
        self.make_request()

    def open(self):
        response = urllib2.urlopen(self.request)
        content = response.read()
        self._dst_url = response.geturl()
        try:
            return json.loads(content)
        except:
            return content

if __name__ == &amp;quot;__main__&amp;quot;:
    import argparse
    import os
    parser = argparse.ArgumentParser()
    parser.add_argument(dest=&amp;quot;path&amp;quot;, nargs=&amp;quot;?&amp;quot;)
    args = parser.parse_args()
    if args.path:
        path = args.path
    else:
        path = r&amp;quot;/tmp/tmpscrot.png&amp;quot;
        os.system(&amp;quot;scrot -s {0}&amp;quot;.format(path))
    form = Form()
    filename = os.path.split(path)[-1]
    form.add_file(fieldname='mypic', filename=filename,
                  fileHandle=open(path))
    http = HttpHelper( __host__ + '/Image/', form)
    url = http.open()
    try:
        from PyQt4.QtGui import QApplication
        app = QApplication([])
        cb = QApplication.clipboard()
        cb.setText(url)
    except:
        print url
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;将上面代码保存一个文件,放在&lt;code&gt;PATH&lt;/code&gt;路径里,赋予&lt;code&gt;执行权限&lt;/code&gt;即可&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;默认的不跟图片地址则会截图,截图完毕后自动分享,如安装了PyQt4库则会将结果放到剪贴板,如没有则输出结果.如果脚本给了图片路径参数则上传给定路径的图片&lt;/p&gt;</summary><category term="Linux"></category><category term="scrot"></category><category term="截图"></category><category term="python"></category></entry><entry><title>vLog使用Tornado框架结合memcached缓存页面</title><link href="http://www.linuxzen.com/vlogshi-yong-tornadokuang-jia-jie-he-memcachedhuan-cun-ye-mian.html" rel="alternate"></link><updated>2013-01-16T16:14:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-01-16:vlogshi-yong-tornadokuang-jia-jie-he-memcachedhuan-cun-ye-mian.html</id><summary type="html">&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;Blog是一个更新并不很频繁的一套系统,但是每次刷新页面都要更新数据库反而很浪费资源,添加静态页面生成是一个解决办法,同时缓存是一个更好的主意,可以结合Memcached添加少量的代码进行缓存,而且免去去了每次更新文章都要重新生成静态页面,特别当页面特别多时.&lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;主要通过页面的uri进行缓存,结合tornado.web.RequestHandler的prepare和on_finish方法函数,
prepare 主要是请求前执行,on_finish()是请求结束之前执行.在渲染模板时缓存页面内容,然后在请求前检测是否有缓存,如果有直接输出缓存,结束请求,在POST提交之后清空所有缓存,重新生成缓存,从而保证内容实时性.由于登录用户和普通用户的页面不相同,所以不缓存登录用户页面(代码中没有体现,请自行实现).主要python代码(省略了模板渲染的代码):&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
#   Author  :   cold
#   E-mail  :   wh_linux@126.com
#   Date    :   13/01/14 09:57:31
#   Desc    :   
#
import config
import pylibmc
from tornado.web import RequestHandler
#### 省略Cache类定义 #####

class Memcached(object):
    _mc = pylibmc.client.Client(config.CACHE_HOST, binary = True)

    def __enter__(self):
        if config.CACHED:
            return Memcached
        else:
            return Cache()

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass

    @classmethod
    def get_cache(cls):
        return cls._mc

    @classmethod
    def get(cls, key, default = None):
        r = cls._mc.get(key)
        if not r:
            r = default
        return r

    @classmethod
    def set(cls, key, value, timeout = 0):
        timeout = timeout if timeout else config.CACHE_TIMEOUT
        return cls._mc.set(key, value, timeout)

    @classmethod
    def delete(cls, key):
        return cls._mc.delete(key)

    @classmethod
    def flush(cls):
        return cls._mc.flush_all()

    def __getattr__(self, key):
        return Memcached.get(key)

    def __setattr__(self, key, value):
        return Memcached.set(key, value)


class BaseHandler(RequestHandler):
    &amp;quot;&amp;quot;&amp;quot; 继承tornado请求基类,重写 prepare和on_finish方法 &amp;quot;&amp;quot;&amp;quot;
    cache = Memcached

    def render(self, template_path, *args, **kwargs):
        &amp;quot;&amp;quot;&amp;quot; 渲染模板 &amp;quot;&amp;quot;&amp;quot;
        # 省略渲染模板代码
        content = ''     # 渲染模板后的内容
        if self.request.method == &amp;quot;GET&amp;quot; and CACHED and \
           not self.request.path.startswith(&amp;quot;/admin&amp;quot;):
            self.cache.set(self.request.uri, content) # 将渲染后的内容缓存起来
        self.write(content)

    def prepare(self):
        super(BaseHandler, self).prepare()
        # 如果请求是GET方法,而且不是请求后台
        if self.request.method == &amp;quot;GET&amp;quot; and CACHED and \
           not self.request.path.startswith(&amp;quot;/admin&amp;quot;):

            # 尝试获取当前页面的缓存
            cache = self.cache.get(self.request.uri)
            # 获取缓存则输出页面,结束请求
            if cache:
                return self.finish(cache)

    def on_finish(self):
        &amp;quot;&amp;quot;&amp;quot; 重写结束请求前的方法函数 &amp;quot;&amp;quot;&amp;quot;
        if self.request.method == &amp;quot;POST&amp;quot;:
            # 如果遇到POST提交则清空缓存
            self.cache.flush()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缓存系统在&lt;code&gt;redis&lt;/code&gt;和&lt;code&gt;Memcached&lt;/code&gt;选择了很久,因为只是单纯的缓存页面所以最后选择了&lt;code&gt;memcached&lt;/code&gt;,使用&lt;code&gt;pylibmc&lt;/code&gt; python库.&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;使用webbench 网站压力测试对比了缓存前后的结果:
使用缓存前&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;$ webbench -c 500 -t 30 http://www.linuxzen.com/
Webbench - Simple Web Benchmark 1.5
Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.

Benchmarking: GET http://www.linuxzen.com/
500 clients, running 30 sec.

Speed=54 pages/min, 38160 bytes/sec.
Requests: 27 susceed, 0 failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用缓存后:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;$ webbench -c 500 -t 30 http://www.linuxzen.com/
Webbench - Simple Web Benchmark 1.5
Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.

Benchmarking: GET http://www.linuxzen.com/
500 clients, running 30 sec.

Speed=256 pages/min, 238544 bytes/sec.
Requests: 128 susceed, 0 failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显快了很多...&lt;/p&gt;</summary><category term="Linux"></category><category term="python"></category><category term="Memcached"></category><category term="pylibmc"></category><category term="缓存"></category><category term="vLog"></category></entry><entry><title>python 使用pyxmpp2编写gtalk群</title><link href="http://www.linuxzen.com/python-shi-yong-pyxmpp2bian-xie-gtalkqun.html" rel="alternate"></link><updated>2012-10-29T14:48:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-10-29:python-shi-yong-pyxmpp2bian-xie-gtalkqun.html</id><summary type="html">&lt;p&gt;gtalk是一款google开发的基于xmpp协议的聊天软件,其优点就是协议开源,我们可以通过任何支持xmpp的客户端协议来链接gtalk,但是gtalk不支持群聊天,所以各路高手都会自己来开发一个机器人来支持群功能.&lt;/p&gt;
&lt;p&gt;其实主要原理就是机器人接收到消息后再将消息广播出去,从而达到群的效果.&lt;/p&gt;
&lt;p&gt;python有两个模块可以用来支持xmpp,分别是pyxmpp和pyxmpp2,之前也用pyxmpp写了一个,功能和兼容性不是很好,经常出现问题,所以又使用pyxmpp2重写了一遍,今天修复了一些bug,所以公布出来,大家可以下载测试,也可以加入我们使用gtalk进行群交流,&lt;/p&gt;
&lt;p&gt;我们的gtalk机器人是:&lt;code&gt;clubot@vim-cn.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;喜欢gtalk,同时喜欢Linux/Python/Vim等爱好者的同学可以加进来交流&lt;/p&gt;
&lt;p&gt;如果对我们的代码比较感兴趣,可以访问github,我们将代码放在了github上:https://github.com/coldnight/clubot&lt;/p&gt;
&lt;p&gt;下面介绍一下安装:&lt;/p&gt;
&lt;p&gt;环境为:python 2.7, 因为有少量的shell所以系统需要Linux,也可稍作更改支持windows&lt;/p&gt;
&lt;p&gt;下载源码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;git clone git://github.com/coldnight/clubot.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装依赖:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;easy_install pyxmpp2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改settings.py文件,填入bot的账户和密码,执行:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;python clubot.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可开启群bot,群bot支持翻译,天气查询,贴代码等等待功能.&lt;/p&gt;
&lt;p&gt;如果您想贡献代码可以加入我们的bot群:&lt;code&gt;clubot@vim-cn.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果您有bug可以提交在评论里&lt;/p&gt;</summary><category term="群"></category><category term="xmpp"></category><category term="pyxmpp2"></category><category term="python"></category><category term="gtalk"></category><category term="bot"></category></entry><entry><title>Python将汉字按拼音排序--一个多音字引发的悲剧</title><link href="http://www.linuxzen.com/pythonjiang-yi-zi-an-pin-yin-pai-xu-ge-duo-yin-zi-yin-fa-de-bei-ju.html" rel="alternate"></link><updated>2012-10-24T18:29:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-10-24:pythonjiang-yi-zi-an-pin-yin-pai-xu-ge-duo-yin-zi-yin-fa-de-bei-ju.html</id><summary type="html">&lt;p&gt;今天同事告诉我一个项目需要将汉字按拼音排序,之前没做过啊,就google之,down了一份汉字与拼音的对照表,对照表格式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拼    pin1
音    yin1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将文件保存为&lt;code&gt;pinyindata&lt;/code&gt;,于是有了如下对应的python代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
# Author : cold night
# E-mail : wh_linux@126.com
# Date   : 12-10-24 下午3:13
#
from os import path
import locale

class SortedByPy:
    __PYDICT__ = dict()
    PYDATA_PATH = path.join(path.dirname(__file__), 'pinyindata')
    def __init__(self):
        if not self.__PYDICT__:
            py_file = open(self.PYDATA_PATH, 'r')
            for line in py_file.readlines():
                word, pinyin = line.split('\t')
                self.__PYDICT__.update({word:pinyin.strip()})
            py_file.close()

    def get_py(self, word):
        &amp;quot;&amp;quot;&amp;quot;
        获取汉字拼音
        &amp;quot;&amp;quot;&amp;quot;
        result = []
        i = word.decode('utf-8')[0].encode('utf-8')
        result.append(self.__PYDICT__.get(i, i))
        result = ''.join(result)
        return result

    def cmp_by_py(self, A, B):
        &amp;quot;&amp;quot;&amp;quot;
        使用拼音比较两个汉字的先后(使用倒序)
        &amp;quot;&amp;quot;&amp;quot;

        r1 = self.get_py(A)
        r2 = self.get_py(B)
        return cmp(r1, r2)

    def sort(self, iterable, key=None, reverse=False):
        &amp;quot;&amp;quot;&amp;quot;
        - `iterable` :
        - `key` : 有则对列表中的字典对应key的值进行排序
        &amp;quot;&amp;quot;&amp;quot;
        result = []
        for i,v in enumerate(iterable):
            f = v[key][0] if key else v[0]
            if f &amp;lt;= 'z':result.append(iterable.pop(i))
        if key:
            result.sort(cmp = lambda x, y: self.cmp_by_py(x[key], y[key]), reverse= reverse)
        else:
            result.sort(reverse=reverse)
        if key:
            r = sorted(iterable, cmp=lambda x, y: self.cmp_by_py(x[key], y[key]), reverse=reverse)
        else:
            r = sorted(iterable, cmp=lambda x, y: self.cmp_by_py(x, y)l, reverse=reverse)
        result.extend(r)
        return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯,写好后测试正常,提交后告诉同事,同事一测发现重庆怎么跑到最后啊,不对啊,有bug啊,我重新将重庆加入到我的测试,真是不行阿,好吧可能是对照表的问题,打开找了下,能找到重啊,难道是decode出问题了,于是打开咱的ipython shell,结果输入重庆,一回车终端崩了,好吧,我再试还是崩,于是我想可能是utf-8的bug或者python的uft-8的bug,于是我将我的想法告知了同事,同事也打开了&lt;code&gt;ipython试&lt;/code&gt;了下,结果他的可以正常输入,正常decode/encode,这下我想可能是方法的问题吧.&lt;/p&gt;
&lt;p&gt;于是看看有无别的办法,看到一个对Linux有效可能对window有效的办法,好嘛正好咱也Linux果断拿过来试试,于是下面的代码诞生了:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
#
# Author : cold night
# E-mail : wh_linux@126.com
# Date   : 12-10-24 下午3:13
#
#from os import path
import locale

class SortedByPy:
    __PYDICT__ = dict()
    #PYDATA_PATH = path.join(path.dirname(__file__), 'pinyindata')
    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        if not self.__PYDICT__:
            py_file = open(self.PYDATA_PATH, 'r')
            for line in py_file.readlines():
                word, pinyin = line.split('\t')
                self.__PYDICT__.update({word:pinyin.strip()})
            py_file.close()
        &amp;quot;&amp;quot;&amp;quot;
        pass

    def get_py(self, word):
        &amp;quot;&amp;quot;&amp;quot;
        获取汉字拼音
        &amp;quot;&amp;quot;&amp;quot;
        result = []
        i = word.decode('utf-8')[0].encode('utf-8')
        result.append(self.__PYDICT__.get(i, i))
        result = ''.join(result)
        return result

    def cmp_by_py(self, A, B):
        &amp;quot;&amp;quot;&amp;quot;
        使用拼音比较两个汉字的先后(使用倒序)
        &amp;quot;&amp;quot;&amp;quot;

        r1 = self.get_py(A)
        r2 = self.get_py(B)
        return cmp(r1, r2)

    def sort(self, iterable, key=None, reverse=False):
        &amp;quot;&amp;quot;&amp;quot;
        - `iterable` :
        - `key` : 有则对列表中的字典对应key的值进行排序
        &amp;quot;&amp;quot;&amp;quot;
        result = []
        &amp;quot;&amp;quot;&amp;quot;
        for i,v in enumerate(iterable):
            f = v[key][0] if key else v[0]
            if f &amp;lt;= 'z':result.append(iterable.pop(i))
        if key:
            result.sort(cmp = lambda x, y: self.cmp_by_py(x[key], y[key]), reverse= reverse)
        else:
            result.sort(reverse=reverse)
        &amp;quot;&amp;quot;&amp;quot;
        locale.setlocale(locale.LC_ALL, 'zh_CN.UTF-8')
        if key:
            r = sorted(iterable, cmp=locale.strcoll, key = lambda x: x[key], reverse=reverse)
        else:
            r = sorted(iterable, cmp=locale.strcoll, reverse=reverse)
        result.extend(r)
        return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写好了跑起来测试嘛,重庆还是躺在了最后,我想这应该就是utf-8的bug了吧,系统都这样了,于是和同事交流后认为也许是bug吧,回到座位后我苦思冥想阿,绞尽脑汁啊,看看有没有别的办法阿,突然一道闪电阿,我明白了,重&lt;code&gt;多音字&lt;/code&gt;啊也读&lt;code&gt;zhong&lt;/code&gt;啊,排在最后是对的啊,没有错误,也没有bug,一个&lt;code&gt;多音字&lt;/code&gt;引发的悲剧哇.&lt;/p&gt;</summary><category term="汉字排序"></category><category term="汉字"></category><category term="排序"></category><category term="拼音"></category><category term="多音字"></category><category term="python"></category></entry><entry><title>用Python将绝对URL替换成相对URL</title><link href="http://www.linuxzen.com/yong-pythonjiang-jue-dui-urlti-huan-cheng-xiang-dui-url.html" rel="alternate"></link><updated>2012-09-29T15:52:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-09-29:yong-pythonjiang-jue-dui-urlti-huan-cheng-xiang-dui-url.html</id><summary type="html">&lt;p&gt;公司一个项目需要上传图片,一开始同事将图片上传后结合当前主机拼成了一个绝对的URL(&lt;a href="#"&gt;http://192.168.1.1:888/m/getimg?filename=xxx.jpg&lt;/a&gt;由于同时给手机终端提供接口,在手机终端会引起一些bug,改完代码后要求将以前的uri替换成相对的URL(/m/getimg?filename=xxx.jpg),由于图片是用img标签嵌入到内容同时用a标签括起显示大图的,所以需要读取数据库并对内容进行替换,&lt;/p&gt;
&lt;p&gt;脚本内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
#-*- coding:utf-8 -*-
#
#
# author  : cold night
# email   : wh_linux@126.com
#

import pymongo
import re
from StringIO import StringIO

conn = pymongo.Connection()
db = conn.test

def replace_url():
    regex = re.compile(r'([href¦src])=[&amp;quot;¦\']http://.*?(/m/getimg\?.*?)[&amp;quot;¦\']')
    results = db['test'].find()
    db_coll = db['test']
    def replace(r):
        content = r.get('content')
        if not content: return
        content = StringIO(content)
        content.seek(0)
        result = StringIO()
        for line in content.readlines():
            t = regex.sub(r'\1=&amp;quot;\2&amp;quot;', line)
            result.write(t)

        result.seek(0)
        content = result.read()
        if content:
            r['content'] = content
        _id = r.get('_id')
        db_coll.update({'_id':_id}, r)

    results = [replace(i) for i in results]

if __name__==&amp;quot;__main__&amp;quot;:replace_url()
&lt;/code&gt;&lt;/pre&gt;</summary><category term="绝对"></category><category term="相对"></category><category term="替换"></category><category term="url"></category><category term="python"></category></entry><entry><title>用Python对各种编程语言进行代码高亮</title><link href="http://www.linuxzen.com/yong-pythondui-ge-chong-bian-cheng-yu-yan-jin-xing-dai-ma-gao-liang.html" rel="alternate"></link><updated>2012-09-29T15:11:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-09-29:yong-pythondui-ge-chong-bian-cheng-yu-yan-jin-xing-dai-ma-gao-liang.html</id><summary type="html">&lt;p&gt;做了一个在线代码高亮的项目,因为写的Gtalk群Bot需要这个功能支持,贴到第三方怕被人给封,所以干脆想自己写一个,强大的Python一如既往没让我失望,一个强大的Pygments模块可以对多种(很多)语言进行代码高亮&lt;/p&gt;
&lt;p&gt;下面来介绍一下它:&lt;/p&gt;
&lt;p&gt;首先安装很简单,使用easy_install来进行安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;easy_install pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完后我们来使用,Python的简单不会让大家失望:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;from pygments.lexers import PythonLexver
from pygments.formatters import HtmlFormatter
from pygments import highlight

formatter = HtmlFormatter(encoding='utf-8', style = 'emacs', linenos = True)
code = highlight('print &amp;quot;hello, world&amp;quot;', PythonLexer(), formatter)

print code
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;结果&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;'&amp;lt;table class=&amp;quot;highlighttable&amp;quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td class=&amp;quot;linenos&amp;quot;&amp;gt;&amp;lt;div class=&amp;quot;linenodiv&amp;quot;&amp;gt;&amp;lt;pre&amp;gt;1&amp;lt;/pre&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td class=&amp;quot;code&amp;quot;&amp;gt;&amp;lt;div class=&amp;quot;highlight&amp;quot;&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;span class=&amp;quot;k&amp;quot;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;amp;quot;hello, world&amp;amp;quot;&amp;lt;/span&amp;gt;\n&amp;lt;/pre&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就简单的对代码进行了高亮,当然如果你做了上面操作,然后把内容输入到一个文件里查看,肯定大呼坑爹,因为根本没高亮,因为默认是不会输出css的 我们还要获取css加入到html中去:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;css = formatter.get_style_defs()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后把css内容和上面的html一起写入到html文件就可以看到高亮的代码了(千万不要告诉我你不知道css应该放在什么位置)&lt;/p&gt;
&lt;p&gt;欢迎大家加入到我们的gtalk群来讨论Python/vim/Linux 或者蛋疼的时候聊聊人生,有很多好玩的功能等着大家.
使用gtalk添加:clubot@vim-cn.com&lt;/p&gt;</summary><category term="高亮"></category><category term="代码"></category><category term="python"></category><category term="pygments"></category></entry><entry><title>Python 优雅的操作字典</title><link href="http://www.linuxzen.com/python-you-ya-de-cao-zuo-zi-dian.html" rel="alternate"></link><updated>2012-09-17T11:42:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-09-17:python-you-ya-de-cao-zuo-zi-dian.html</id><summary type="html">&lt;p&gt;Python 中的字典是Python中一个键值映射的数据结构,下面介绍一下如何优雅的操作字典.&lt;/p&gt;
&lt;h2&gt;1.1 创建字典&lt;/h2&gt;
&lt;p&gt;Python有两种方法可以创建字典,第一种是使用花括号,另一种是使用内建
函数dict&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = {}
&amp;gt;&amp;gt;&amp;gt; info = dict()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.2 初始化字典&lt;/h2&gt;
&lt;p&gt;Python可以在创建字典的时候初始化字典&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = {&amp;quot;name&amp;quot; : 'cold'}
&amp;gt;&amp;gt;&amp;gt; info = dict(name = 'cold')       # 更优雅
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显第二种方法更加的优雅和减少一些特殊字符的输入,但是有种情况第二种不能胜任&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; key = 'name'
&amp;gt;&amp;gt;&amp;gt; info = { key :'cold'}  # {'name':'cold'}
&amp;gt;&amp;gt;&amp;gt; info = dict(key = 'cold') # {'key': 'cold'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显第二种方法就会引发一个不容易找到的bug&lt;/p&gt;
&lt;p&gt;Python字典还有一种初始化方式,就是使用字典的fromkeys方法可以从列表中获取元素作为键并用None或fromkeys方法的第二个参数初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = {}.fromkeys(['name', 'blog'])
&amp;gt;&amp;gt;&amp;gt; info
{'blog': None, 'name': None}
&amp;gt;&amp;gt;&amp;gt; info = dict().fromkeys(['name', 'blog'])
&amp;gt;&amp;gt;&amp;gt; info
{'blog': None, 'name': None}
&amp;gt;&amp;gt;&amp;gt; info = dict().fromkeys(['name', 'blog'], 'linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com', 'name': 'linuxzen.com'}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.3 优雅的获取键值&lt;/h2&gt;
&lt;p&gt;字典可以这样获取到键的值&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = {'name':'cold', 'blog':'linuxzen.com'}
&amp;gt;&amp;gt;&amp;gt; info['name']
'cold'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果获取不存在的键的值就会触发的一个KeyError异常,字典有一个get方法,可以使用字典get方法更加优雅的获取字典&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name= 'cold', blog='www.linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; info.get('name')
'cold'
&amp;gt;&amp;gt;&amp;gt; info.get('blogname')
None
&amp;gt;&amp;gt;&amp;gt; info.get('blogname', 'linuxzen')
'linuxzen'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到使用get方法获取不存在的键值的时候不会触发异常,同时get方法接收两个参数,当不存在该键的时候就会返回第二个参数的值
我们可以看到使用get更加的优雅&lt;/p&gt;
&lt;h2&gt;1.4 更新/添加&lt;/h2&gt;
&lt;p&gt;Python 字典可以使用键作为索引来访问/更新/添加值&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict()
&amp;gt;&amp;gt;&amp;gt; info['name'] = 'cold'
&amp;gt;&amp;gt;&amp;gt; info['blog'] = 'linuxzen.com'
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com', 'name': 'cold'}
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com', 'name': 'cold night'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时Python字典的update方法也可以更新和添加字典&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name='cold', blog='linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; info.update({'name':'cold night', 'blogname':'linuxzen'})
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com', 'name': 'cold night', 'blogname': 'linuxzen'}
&amp;gt;&amp;gt;&amp;gt; info.update(name='cold', blog='www.linuxzen.com') # 更优雅
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'www.linuxzen.com', 'name': 'cold', 'blogname': 'linuxzen'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python字典的update方法可以使用一个字典来更新字典,也可以使用参数传递类似dict函数一样的方式更新一个字典,上面代码中哦功能的第二个更加优雅,但是同样和dict函数类似,键是变量时也只取字面值&lt;/p&gt;
&lt;h2&gt;1.5 字典删除&lt;/h2&gt;
&lt;p&gt;可以调用Python内置关键字del来删除一个键值&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name='cold', blog='linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com', 'name': 'cold'}
&amp;gt;&amp;gt;&amp;gt; del info['name']
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时也可以使用字典的pop方法来取出一个键值,并删除&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name='cold', blog='linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; info.pop('name')
'cold'
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'linuxzen.com'}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.6 其他操作&lt;/h2&gt;
&lt;p&gt;获取所有key&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name='cold', blog='linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; info.keys()
['blog', 'name']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取key,value并循环&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name='cold', blog='linuxzen.com')
&amp;gt;&amp;gt;&amp;gt; for key, value in info.items():
...     print key, ':',  value
... 
blog : linuxzen.com
name : cold
&lt;/code&gt;&lt;/pre&gt;</summary><category term="操作"></category><category term="字典"></category><category term="优雅"></category><category term="python"></category><category term="dict"></category></entry><entry><title>Python 字典和列表陷阱</title><link href="http://www.linuxzen.com/python-zi-dian-he-lie-biao-xian-jing.html" rel="alternate"></link><updated>2012-09-17T10:22:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-09-17:python-zi-dian-he-lie-biao-xian-jing.html</id><summary type="html">&lt;p&gt;Python 中有三个非常好用的数据结构,列表,元组和字典,
元组是不可变的,列表可以保存任意类型的Python对象,并可以随意扩展没有大小限制,
字典是一个key-value的键值映射的类型,可以存放任何Python对象,可以嵌套字典,
值可以是字典元组或者字典&lt;/p&gt;
&lt;p&gt;这里说是Python 字典和列表的陷阱不如说是Python的一些特性,如果不了解这些特性
就会引发一些难以寻找的bug&lt;/p&gt;
&lt;p&gt;下面我们来介绍这些特性&lt;/p&gt;
&lt;p&gt;Python中所有对列表和字典的使用仅仅是对原来对象的引用而不是创建一个新的对象
如下面代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; info = dict(name='cold', blog='www.linuxzen.com') # 创建字典{'name':'cold', 'blog':'www.linuxzen.com'}
&amp;gt;&amp;gt;&amp;gt; info2 = info     # 赋值给info2
&amp;gt;&amp;gt;&amp;gt; info2['name'] = 'cold night'
&amp;gt;&amp;gt;&amp;gt; info
&amp;gt;&amp;gt;&amp;gt; info2
{'blog': 'www.linuxzen.com', 'name': 'cold night'}
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'www.linuxzen.com', 'name': 'cold night'}
&amp;gt;&amp;gt;&amp;gt; names = ['cold', 'night', 'linuxzen']
&amp;gt;&amp;gt;&amp;gt; names2 = names
&amp;gt;&amp;gt;&amp;gt; names2.append('cold night')
&amp;gt;&amp;gt;&amp;gt; names
['cold', 'night', 'linuxzen', 'cold night']
&amp;gt;&amp;gt;&amp;gt; names2
['cold', 'night', 'linuxzen', 'cold night']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家看到如果将列表或者字典重新赋值给另外一个变量并没有达到预想的效果,
我们更改一个的同时另外一个也在同时更改,如果我们想保留一个快照,很明显我们
没有达到我们想要的效果,另外还有一种常见的使用,因为我们知道普通变量传递给
函数,函数在内部更改是不会影响到外部变量的,那么列表和字典呢?
我们来看如下代码,我们创建一个函数,是字典就添加一个键和值,是列表就在尾部添加一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; def add_something(info):
...     if type(info) == dict:
...             info['msg'] = 'Hello,'+ info['name']
...     elif type(info) == list:
...             info.append('add to the list')
... 
&amp;gt;&amp;gt;&amp;gt; info = {'name':'cold', 'blog':'www.linuxzen.com'}
&amp;gt;&amp;gt;&amp;gt; add_something(info)
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'www.linuxzen.com', 'msg': 'Hello,cold', 'name': 'cold'}
&amp;gt;&amp;gt;&amp;gt; names = ['cold', 'night', 'linuxzen.com']
&amp;gt;&amp;gt;&amp;gt; add_something(names)
&amp;gt;&amp;gt;&amp;gt; names
['cold', 'night', 'linuxzen.com', 'add to the list']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码明显不是我们想要的结果,如果这个列表/字典仅仅用在一个地方可能不会发生什么
如果我们其他地方需要同样的列表进行处理,如果你不知道这个特性就会产生很难寻找的bug
当上面并不是我们想要的我们该如何避免上面呢,我们可以对列表/字典做一个拷贝,而不是
简单的引用&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; names = ['cold', 'night', 'linuxzen.com']
&amp;gt;&amp;gt;&amp;gt; names2 = names[:]
&amp;gt;&amp;gt;&amp;gt; names2.append('cold night')
&amp;gt;&amp;gt;&amp;gt; names
['cold', 'night', 'linuxzen.com']
&amp;gt;&amp;gt;&amp;gt; names2
['cold', 'night', 'linuxzen.com', 'cold night']
&amp;gt;&amp;gt;&amp;gt; info = {'name':'cold night', 'blog':'www.linuxzen.com'}
&amp;gt;&amp;gt;&amp;gt; info2 = info.copy()
&amp;gt;&amp;gt;&amp;gt; info2['name'] = 'cold'
&amp;gt;&amp;gt;&amp;gt; info
{'blog': 'www.linuxzen.com', 'name': 'cold night'}
&amp;gt;&amp;gt;&amp;gt; info2
{'blog': 'www.linuxzen.com', 'name': 'cold'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码列表使用[:]可以创建一个列表的副本而不是引用
字典的copy方法同样可以创建一个字典的副本而不是引用
这样就可以避免之前所说的引用的情况&lt;/p&gt;</summary><category term="陷阱"></category><category term="引用"></category><category term="字典"></category><category term="列表"></category><category term="python"></category></entry><entry><title>用bottle+mongodb写的blog程序支持mysql啦</title><link href="http://www.linuxzen.com/yong-bottlemongodbxie-de-blogcheng-xu-zhi-chi-mysqlla.html" rel="alternate"></link><updated>2012-08-14T09:16:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-08-14:yong-bottlemongodbxie-de-blogcheng-xu-zhi-chi-mysqlla.html</id><summary type="html">&lt;p&gt;前面博文提到过,本人用bottle+mongodb实现了以blog程序,&lt;/p&gt;
&lt;p&gt;最近有些空闲时间,就重新用mvc的模式重写了一下,因为mongodb太过耗费内存,对一些小型的vps太过吃力所以加入了mysql的支持,&lt;/p&gt;
&lt;p&gt;虽然较上次有些完善,但是还是有很多不足代码放在了googlecode上,由于最近一直在使用git,索性也就新建了一个git的项目,之前svn的项目也会更新.&lt;/p&gt;
&lt;p&gt;所以大家想浏览代码可以到下面两个地方去,有什么不足和建议还请指教,如果你也想加入进来,可以留言或发email给我:&lt;/p&gt;
&lt;p&gt;git:&lt;a href="http://code.google.com/p/linuxzen/source/browse/water"&gt;http://code.google.com/p/linuxzen/source/browse/water&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;svn:http://code.google.com/p/sharepythoncode/source/browse/water/&lt;/p&gt;</summary><category term="支持mysql"></category><category term="web"></category><category term="python"></category><category term="MySQL"></category><category term="mongodb"></category><category term="bottle"></category><category term="blog"></category></entry><entry><title>python里的三目运算</title><link href="http://www.linuxzen.com/pythonli-de-san-mu-yun-suan.html" rel="alternate"></link><updated>2012-08-10T16:28:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-08-10:pythonli-de-san-mu-yun-suan.html</id><summary type="html">&lt;p&gt;下面说的和三目运算有点相似,但又不一样,实在不知道该如何拟定标题,先就是这个标题吧,大家都知道python中没有三目运算,但是&lt;code&gt;and&lt;/code&gt;/&lt;code&gt;or&lt;/code&gt;有点类似三目运算:&lt;/p&gt;
&lt;h2&gt;and/or&lt;/h2&gt;
&lt;p&gt;单独使用表示逻辑关系与和或,也可以组和使用,用法如下&lt;/p&gt;
&lt;h3&gt;and&lt;/h3&gt;
&lt;p&gt;and前后如果某一个值为假(False, '', [], {}, None…)则返回第一个假值
如果所有值都为真则返回最后一个真值&lt;/p&gt;
&lt;h3&gt;or&lt;/h3&gt;
&lt;p&gt;如果or任意一个值为真,则立刻返回这个值
如果所有值都为假,则or返回最后一个假值&lt;/p&gt;
&lt;h3&gt;例子&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;result = 'test' and True # result = True
result = 'test' and 'ortest' # result = ortest
result = False and 'ortest' # result = False
result = '' and None  # result = ''

result = '' or &amp;quot;Hall&amp;quot; # result = Hall
result = False or None # result = None
result = 'test' or 'nottest' # result = test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用单行if else 模拟三目运算&lt;/h2&gt;
&lt;p&gt;result if True / False else fresult
if为真时候结果为result,为假的时候结果为fresult&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;result = 'test' if True else 'not test' # result = 'test'
result = 'test' if False else 'not test' # result = 'not test'
&lt;/code&gt;&lt;/pre&gt;</summary><category term="单行"></category><category term="三目"></category><category term="python"></category><category term="or"></category><category term="if"></category><category term="else"></category><category term="and"></category></entry><entry><title>Python 断点调试</title><link href="http://www.linuxzen.com/python-duan-dian-diao-shi.html" rel="alternate"></link><updated>2012-08-10T16:16:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-08-10:python-duan-dian-diao-shi.html</id><summary type="html">&lt;h2&gt;pdb模块&lt;/h2&gt;
&lt;p&gt;pdb是一个Python 内置的调式模块这里用来介绍用它进行断点调试&lt;/p&gt;
&lt;h3&gt;插入断点&lt;/h3&gt;
&lt;p&gt;在需要插入断点的地方插入如下代码可以插入一个断点
import pdb; pdb.set_trace()
当Python执行到这条语句时在运行shell里就会中断执行出现一个类似下面的shell窗口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # 这里会出现当前运行程序的信息,源文件和当前函数
-&amp;gt; # 这里是将要运行的语句
 (Pdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;pdb指令&lt;/h3&gt;
&lt;p&gt;进入(Pdb)后有很多命令可以使用,可以使用 &lt;code&gt;h&lt;/code&gt; 查看帮助&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;l 查看代码上下文&lt;/li&gt;
&lt;li&gt;p var 监视变量var&lt;/li&gt;
&lt;li&gt;n 单步执行&lt;/li&gt;
&lt;li&gt;b line  在line行插入断点&lt;/li&gt;
&lt;li&gt;c 继续到下一个断点,没有则执行程序&lt;/li&gt;
&lt;li&gt;r 执行到函数返回前&lt;/li&gt;
&lt;/ul&gt;</summary><category term="调试"></category><category term="断点"></category><category term="python"></category><category term="pdb"></category><category term="debug"></category></entry><entry><title>lambda 结合map/filter/reduce/sorted等函数对列表进行高效操作</title><link href="http://www.linuxzen.com/lambda-jie-he-mapfilterreducesorteddeng-han-shu-dui-lie-biao-jin-xing-gao-xiao-cao-zuo.html" rel="alternate"></link><updated>2012-08-10T16:02:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-08-10:lambda-jie-he-mapfilterreducesorteddeng-han-shu-dui-lie-biao-jin-xing-gao-xiao-cao-zuo.html</id><summary type="html">&lt;p&gt;lambda 结合map/filter/reduce/sorted等函数对列表进行高效操作&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3&gt;lambda&lt;/h3&gt;
&lt;p&gt;Python用于支持将函数赋值给变量的一个操作符
默认是返回的,所以不用再加return关键字,不然会报错&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;result = lambda x:  x * x
result(2) # return 4
map()/filter()/reduce()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要两个参数,第一个是一个处理函数,第二个是一个序列(list,tuple,dict)&lt;/p&gt;
&lt;h3&gt;map()&lt;/h3&gt;
&lt;p&gt;将序列中的元素通过处理函数处理后返回一个新的列表&lt;/p&gt;
&lt;h3&gt;filter()&lt;/h3&gt;
&lt;p&gt;将序列中的元素通过函数过滤后返回一个新的列表&lt;/p&gt;
&lt;h3&gt;reduce()&lt;/h3&gt;
&lt;p&gt;将序列中的元素通过一个二元函数处理返回一个结果&lt;/p&gt;
&lt;h2&gt;将上面三个函数和lambda结合使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class="python"&gt;li = [1, 2, 3, 4, 5]
# 序列中的每个元素加1
map(lambda x: x+1, li) # [2,3,4,5,6]

# 返回序列中的偶数
filter(lambda x: x % 2 == 0, li) # [2, 4]

# 返回所有元素相乘的结果
reduce(lambda x, y: x * y, li) # 1*2*3*4*5 = 120
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;sorted() 结合lambda对列表进行排序&lt;/h2&gt;
&lt;p&gt;sorted 用于列表的排序,比列表自带的更加智能
有两个列表,每个列表中都有一个字典([{},{}])要求将两个这样的列表合并后按照时间排序,
两个列表中的时间为了能够通过json输出已经由时间格式转变为字符串格式.字段名为 sort_time
现在将他们按照倒序排列&lt;/p&gt;
&lt;h3&gt;sorted 的用法&lt;/h3&gt;
&lt;p&gt;sorted(iterable, cmp=None, key=None, reverse=False) --&amp;gt; new sorted list
&lt;em&gt; terable：是可迭代类型;
&lt;/em&gt; cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项;
&lt;em&gt; key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项;
&lt;/em&gt; reverse：排序规则. reverse = True 或者 reverse = False，有默认值。
* 返回值：是一个经过排序的可迭代类型，与iterable一样。&lt;/p&gt;
&lt;h3&gt;sorted()结合lambda对可迭代类型用sort_time排序&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;sorted(data, key=lambda d: d['sort_time'], reverse=True)
&lt;/code&gt;&lt;/pre&gt;</summary><category term="排序"></category><category term="列表"></category><category term="sorted"></category><category term="reduce"></category><category term="python"></category><category term="map"></category><category term="list"></category><category term="lambda"></category><category term="filter"></category></entry><entry><title>Python 常用的列表操作</title><link href="http://www.linuxzen.com/python-chang-yong-de-lie-biao-cao-zuo.html" rel="alternate"></link><updated>2012-08-10T15:48:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-08-10:python-chang-yong-de-lie-biao-cao-zuo.html</id><summary type="html">&lt;p&gt;这里介绍几个常用的列表操作&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;添加元素使用列表的内置方法append&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;number = [1, 2, 3, 4]
number.append(5) # number = [1, 2, 3, 4, 5]
number.append([6,7]) # number = [1, 2, 3, 4, 5, [6, 7]]
number.append({'a':'b'}) # number = [1, 2, 3, 4, [6, 7], {'a', :'b'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到强大的python列表可以嵌套任意类型&lt;/p&gt;
&lt;h3&gt;列表相加&lt;/h3&gt;
&lt;p&gt;要想连接两个列表,可以使用+号连接&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;a = [1, 2, 3]
b = [4, 5, 6]
c = a + b # c = [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用列表内置方法extend连接两个列表&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;a = [1, 2, 3]
b = [4, 5, 6]
a.extend(b) # a = [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用+号会创建一个新通对象,使用extend则在原来的对象上面修改&lt;/p&gt;
&lt;h3&gt;列表去重复&lt;/h3&gt;
&lt;p&gt;列表本身没有去除重复的功能,但是可以借助python的另外一个类型set(help(set)查看)&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;a = [1, 2, 3, 3,2, 1]
b = list(set(a)) # b = [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以借助字典类型的内置方法&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;a = [1, 2, 2, 3, 1, 3]
b = {}.fromkeys(a).keys() # b = [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;</summary><category term="重复"></category><category term="相加"></category><category term="添加"></category><category term="列表"></category><category term="python"></category></entry><entry><title>Python超简单截取中文字符串</title><link href="http://www.linuxzen.com/pythonchao-jian-dan-jie-qu-zhong-wen-zi-fu-chuan.html" rel="alternate"></link><updated>2012-07-11T17:55:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-07-11:pythonchao-jian-dan-jie-qu-zhong-wen-zi-fu-chuan.html</id><summary type="html">&lt;p&gt;web应用难免会截取字符串的需求,Python中截取英文很容易:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; s = 'abce'
&amp;gt;&amp;gt;&amp;gt; s[0:3]
'abc'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是截取utf-8的中文机会截取一半导致一些不是乱码的乱码.其实utf8截取很简单,这里记下来作为备忘&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#-*- coding:utf8 -*-
s = u'中文截取'
s.decode('utf8')[0:3].encode('utf8')
# 结果u'中文截取
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就这么简单&lt;/p&gt;</summary><category term="截取"></category><category term="字符串"></category><category term="utf8"></category><category term="python"></category></entry><entry><title>mongoengine使用笔记</title><link href="http://www.linuxzen.com/mongoengineshi-yong-bi-ji.html" rel="alternate"></link><updated>2012-06-23T10:02:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-06-23:mongoengineshi-yong-bi-ji.html</id><summary type="html">&lt;p&gt;最近重新拾起Django,但是Django并不支持mongodb,但是有一个模块mongoengine可以实现Django Model类似的封装.但是mongoengine的中文文档几乎没有,有的也是简短的几句介绍和使用.下面我就分享一下我在使用过程中所记录下的一些笔记,可能有点乱.大家可以参考一下.&lt;/p&gt;
&lt;h2&gt;安装mongoengine&lt;/h2&gt;
&lt;pre&gt;&lt;code class="python"&gt;easy_install pymongo # 依赖库
easy_install mongoengine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基本使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class="python"&gt;from mongoengine import *
from datetime import datetime
# 连接数据库
connect('blog')   # 连接本地blog数据库
# 如需验证和指定主机名
# connect('blog', host='192.168.3.1', username='root', password='1234')

# 定义分类文档
class Categories(Document):
    ' 继承Document类,为普通文档 '
    name = StringField(max_length=30, required=True)
    artnum = IntField(default=0, required=True)
    date = DateTimeField(default=datetime.now(), required=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和Django的model使用很类似,所以也不解释什么.&lt;/p&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;cate = Categories(name=&amp;quot;Linux&amp;quot;)   # 如果required为True则必须赋予初始值,如果有default,赋予初始值则使用默认值
cate.save() # 保存到数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;查询和更新&lt;/h3&gt;
&lt;p&gt;文档类有一个 objects 属性.我们使用它来查询数据库.&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;# 返回集合里的所有文档对象的列表
cate = Categories.objects.all()

# 返回所有符合查询条件的结果的文档对象列表
cate = Categories.objects(name=&amp;quot;Python&amp;quot;)
# 更新查询到的文档:
cate.name = &amp;quot;LinuxZen&amp;quot;
cate.update()
查询数组 默认查询数组&amp;quot;=&amp;quot;代表的意思是in:
class Posts(Document):
    artid = IntField(required=True)
    title = StringField(max_length=100, required=True)
    content = StringField(required=True)
    author = ReferenceField(User)
    tags = ListField(StringField(max_length=20, required=True), required=True)
    categories = ReferenceField(Categories), required=True)
    comments = IntField(default=0, required=True)

# 将会返回所有tags包含coding的文档
Posts.objects(tags='coding')
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;ReferenceField 引用字段:&lt;/h3&gt;
&lt;p&gt;通过引用字段可以通过文档直接获取引用字段引用的那个文档:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;class Categories(Document):
    name = StringField(max_length=30, required=True)
    artnum = IntField(default=0, required=True)
    date = DateTimeField(default=datetime.now(), required=True)

class Posts(Document):

    title = StringField(max_length=100, required=True)
    content = StringField(required=True)
    tags = ListField(StringField(max_length=20, required=True), required=True)
    categories = ReferenceField(Categories)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;插入引用字段&lt;/h4&gt;
&lt;pre&gt;&lt;code class="python"&gt;cate =Categories(name=&amp;quot;Linux&amp;quot;)
cate.save()
post = Posts(title=&amp;quot;Linuxzen.com&amp;quot;, content=&amp;quot;Linuxzen.com&amp;quot;,tags=[&amp;quot;Linux&amp;quot;,&amp;quot;web&amp;quot;], categories=cate)
post.save()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;通过引用字段直接获取引用文档对象&lt;/h4&gt;
&lt;p&gt;一般文档查询会返回一个列表(尽管只有一个结果),我们想要获得一个文档对象可以使用索引获取第一个文档对象,但是mongoengine建议使用first()来获取第一个:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; cate = Posts.objects.all().first().categories
&amp;gt;&amp;gt;&amp;gt; cate

&amp;gt;&amp;gt;&amp;gt; cate.name
u'Linux'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询包含Linux分类的文章&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; cate = Categories.objects(name=&amp;quot;Linux&amp;quot;).first()
&amp;gt;&amp;gt;&amp;gt; Posts.objects(categories=cate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;EmbeddedDocument 嵌入文档&lt;/h3&gt;
&lt;p&gt;继承EmbeddedDocument的文档类就是嵌入文档,嵌入文档用于嵌入其他文档的EmbeddedDocumentField 字段,比如上面例子的tags字段如果改成嵌入文档的话可以将Posts文档类改成如下方式:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;class Posts(Document):

    title = StringField(max_length=100, required=True)
    content = StringField(required=True)
    tags = ListField(EmbeddedDocumentField('Tags')required=True)
    categories = ReferenceField(Categories)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要添加一个Tags嵌入文档类:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;class Tags(EmbeddedDocument):
name = StringField()
date = DateTimeField(default=datetime.now())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们像如下方式插入Posts文档中的Tags&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; tag = Tags(name=&amp;quot;Linuxzen&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; post = Posts(title=&amp;quot;Linuxzen.com&amp;quot;, content=&amp;quot;Linuxzen.com&amp;quot;, tags=[tag], categories=cate)
&amp;gt;&amp;gt;&amp;gt; tag = Tags(name=&amp;quot;mysite&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; post.tags.append(tag)
&amp;gt;&amp;gt;&amp;gt; post.save()
&amp;gt;&amp;gt;&amp;gt; tags = post.tags
&amp;gt;&amp;gt;&amp;gt; for tag in tags:
print tag.name

Linuxzen
mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;时间段查询&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;    start = datetime(int(year), int(month), 1)
    if int(month) + 1 &amp;gt; 12:
        emonth = 1
        eyear = int(year) + 1
    else:
        emonth = int(month) + 1
        eyear = int(year)
    end = datetime(eyear, emonth, 1)
    articles = Posts.objects(date__gte=start, date__lt=end).order_by('-date')
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;分片&lt;/h3&gt;
&lt;p&gt;slice用于分片&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;# comments - skip 5, limit 10
Page.objects.fields(slice__comments=[5, 10])

# 也可以使用索引值分片

# limit 5
users = User.objects[:5]

# skip 5
users = User.objects[5:]

# skip 10, limit 15
users = User.objects[10:15]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用原始语句查询&lt;/h3&gt;
&lt;p&gt;如果想使用原始的pymongo查询方式可以使用&lt;strong&gt;raw&lt;/strong&gt;操作符 Page.objects(&lt;strong&gt;raw&lt;/strong&gt;={'tags':'coding'})
使用$inc和$set操作符&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;# 更新嵌入文档comments字段by的值为joe的文档字段votes增加1
Page.objects(comments_by=&amp;quot;joe&amp;quot;).update(inc__votes=1)

# 更新嵌入文档comments字段by的值为joe的文档字段votes设置为1
Page.objects(comments_by=&amp;quot;joe&amp;quot;).update(set__votes=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;其他技巧&lt;/h3&gt;
&lt;pre&gt;&lt;code class="python"&gt;#查询结果转换成字典
users_dict = User.objects().to_mongo()

# 排序,按日期排列
user = User.objects.order_by(&amp;quot;date&amp;quot;)

# 按日期倒序

user = User.objects.order_by(&amp;quot;-date&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;</summary><category term="python"></category><category term="pymongo"></category><category term="nosql"></category><category term="mongoengine"></category><category term="mongodb"></category></entry><entry><title>bottle使用Python装饰器巧妙解决用户验证</title><link href="http://www.linuxzen.com/bottleshi-yong-pythonzhuang-shi-qi-qiao-miao-jie-jue-yong-hu-yan-zheng.html" rel="alternate"></link><updated>2012-06-16T17:33:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-06-16:bottleshi-yong-pythonzhuang-shi-qi-qiao-miao-jie-jue-yong-hu-yan-zheng.html</id><summary type="html">&lt;p&gt;上篇文章发布了一个自己写的用bottle写的web程序,其中收获最大就是Python装饰器的使用.前几天也是比较忙,所以没能分享出来,今天就给大家分享一下.&lt;/p&gt;
&lt;p&gt;首先来分析下需求,web程序后台需要认证,后台页面包含多个页面,最普通的方法就是为每个url添加认证,但是这样就需要每个每个绑定url的后台函数都需要添加类似或者相同的代码,但是这样做代码就过度冗余,而且不利于扩展.&lt;/p&gt;
&lt;p&gt;接下来我们先不谈及装饰器,我们都知道Python是个很强大的语言,她可以将函数当做参数传递给函数,最简单的:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;def p():
    print 'Hello,world'

def funcfactor(func):
    print 'calling function named', func.__name__
    func()
    print 'end'

funcfactor(p)
# 输出为:
# calling function named p
# Hello,world
# end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一目了然的程序,定义一个函数p(),将函数p当做参数传递给喊出funcfactor,在执行p函数前后加上一些动作.&lt;/p&gt;
&lt;p&gt;我们还可以这么做:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;def p():
    print 'Hello,world'
def funcfactor(func):
    print 'calling function named', func.__name__
    return func

func = funcfactor(p)
func()
# 输出为:
# calling function named p
Hello,world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你看到的,我们可以将函数返回然后赋予一个变量,留待稍后调用.但是这种情况下我们要想在函数执行后做点什么就不可能,但是我们的Python是强大的,Python可以在函数中再嵌套一个函数,我们可以像下面这么做:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;def p():
    print 'Hello, world'

def funcfactor(func):
    def wrapper():
        print 'do something at start'
        func()
        print 'do something at end'
    return wrapper

func = funcfactor(p)
func()
#输出为:
# do something at start
# Hello, world
# do something at end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来看看装饰器,上面的代码虽然实现的一个很困难的任务,但是还不够优雅,而且代码不符合Python的哲学思想,所以装饰器就应声而出,装饰器没有和上面的原理相同,同样用于包装函数,只是代码实现上更加优雅和便于阅读.装饰器以@开头后面跟上装饰器的名称,紧接着下一行就是要包装的函数体,上面的例子用装饰器可用如下方式实现:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;def decorator(func):
    def wrapper():
        print 'do something at start'
        func()
        print 'do something at end'
    return wrapper

@decorator
def p():
    print 'Hello, world'

p()
#输出为:
# do something at start
# Hello, world
# do something at end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上装饰器并没有性能方面或其他方面的提升,仅仅是一种语法糖,就是上面一个例子的改写,这样更加优雅和便与阅读.
如果我们的p()函数不想仅仅只输Hello,world,我们想向某些我们指定的人打招呼:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;def decorator(func):
    def wrapper(*args, **kargs):
        print 'do something at start'
        func(**kargs)
        print 'do something at end'
    return wrapper

@decorator
def p(name):
    print 'Hello', name

p(name=&amp;quot;Jim&amp;quot;)
#输出为:
# do something at start
# Hello Jim
# do something at end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰器在装饰不需要参数的装饰器嵌套函数不是必须得,如果被装饰的函数需要参数,必须嵌套一个函数来处理参数.
写到这里想必大家也知道装饰器的用法和作用.现在回到正题,如何优雅的给后台url加上验证功能?毫无疑问我们使用装饰器来处理:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;def blog_auth(func):
    '''
    定义一个装饰器用于装饰需要验证的页面
    装饰器必须放在route装饰器下面
    '''
    # 定义包装函数
    def wrapper(*args, **kargs):
        try:
            # 读取cookie
            user = request.COOKIES['user']
            shell = request.COOKIES['shell']
        except:
            # 出现异常则重定向到登录页面
            redirect('/login')

        # 验证用户数据
        if checkShell(user, shell):
            # 校验成功则返回函数
            return func(**kargs)
        else:
            # 否则则重定向到登录页面
            redirect('/login')
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以再需要验证的地方添加blog_auth装饰器:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;@route('/admin:#/?#')
@blog_auth
def admin():
    '''
    用于显示后台管理首页
    '''
    TEMPLATE['title'] = '仪表盘 | ' + TEMPLATE['BLOG_NAME']
    TEMPLATE['user'] = request.COOKIES['user']
    articles = []
    for article in db.posts.find().sort(&amp;quot;date&amp;quot;,DESCENDING).limit(10):
        articles.append(article)

    # 将文章列表交给前台模版
    TEMPLATE['articles'] = articles
    return template('admin.html',TEMPLATE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此bottle验证的问题就很优雅的用装饰器解决了.&lt;/p&gt;</summary><category term="验证"></category><category term="装饰器"></category><category term="用户"></category><category term="python"></category><category term="bottle"></category></entry><entry><title>用bottle+mongodb写的一个blog程序</title><link href="http://www.linuxzen.com/yong-bottlemongodbxie-de-ge-blogcheng-xu.html" rel="alternate"></link><updated>2012-06-16T16:20:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-06-16:yong-bottlemongodbxie-de-ge-blogcheng-xu.html</id><summary type="html">&lt;p&gt;我个人觉得更好更快的学习和掌握某个东西最好的方法就是使用它,多使用它.然后在一次次的解决问题中来快速掌握和了解它.你觉得呢?前段时间接触了bottle这个轻量web框架,和nosql数据库mongodb,为了掌握和了解这她们,我自己做了一个blog程序,参照了vimer.cn里的设计的物理设计.是用bottle作为web开发框架,mongodb作为后台数据库.主要实现功能:&lt;/p&gt;
&lt;p&gt;前台显示文章:
按分类显示
按标签显示
按月份归档显示
最新文章
评论
后台管理:
管理文章
管理分类
管理评论
发表文章
用户验证&lt;/p&gt;
&lt;p&gt;目录结构&lt;/p&gt;
&lt;p&gt;water&lt;/p&gt;
&lt;p&gt;+-app           程序目录&lt;/p&gt;
&lt;p&gt;|----admin.py  后台管理&lt;/p&gt;
&lt;p&gt;|----blog.py   前台显示&lt;/p&gt;
&lt;p&gt;|----dbconn.py 数据库连接&lt;/p&gt;
&lt;p&gt;|----encrypt.py包含加密函数&lt;/p&gt;
&lt;p&gt;+-static       静态文件目录:包括js css image&lt;/p&gt;
&lt;p&gt;+-views        模版目录&lt;/p&gt;
&lt;p&gt;+-index.py     用于启动整个程序&lt;/p&gt;
&lt;p&gt;+-initiate.py  初始化脚本,用于创建一个管理用户&lt;/p&gt;
&lt;p&gt;+-setting.py   设置文件,各种设置&lt;/p&gt;
&lt;p&gt;+-static.py    用于程序处理静态文件&lt;/p&gt;
&lt;p&gt;项目代码放在了google code上,可以访问下面链接浏览:
http://code.google.com/p/sharepythoncode/source/browse/water/&lt;/p&gt;</summary><category term="项目"></category><category term="实例"></category><category term="web"></category><category term="python"></category><category term="mongodb"></category><category term="bottle"></category></entry><entry><title>bottle的cookie操作小记(获取不是在当前页面创建的cookie)</title><link href="http://www.linuxzen.com/bottlede-cookiecao-zuo-xiao-ji-huo-qu-bu-shi-zai-dang-qian-ye-mian-chuang-jian-de-cookie.html" rel="alternate"></link><updated>2012-06-02T17:51:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-06-02:bottlede-cookiecao-zuo-xiao-ji-huo-qu-bu-shi-zai-dang-qian-ye-mian-chuang-jian-de-cookie.html</id><summary type="html">&lt;p&gt;这两天为用bottle+mongodb写的一个项目加上登录功能,无奈怎么都获取不到保存的cookie,文档给出让我们这样操作cookie的代码片段:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;@route(’/login’)
def login ():
      username = request .forms .get(’username ’)
      password = request .forms .get(’password ’)
      if check_user_credentials(username, password):
           response .set_cookie(&amp;quot;account&amp;quot;, username, secret= ’some-secret-key’)
           return &amp;quot;Welcome %s!You are now logged in.&amp;quot; % username
      else :
           return &amp;quot;Login failed.&amp;quot; 

@route(’/restricted’)
def restricted_area ():
      username = request .get_cookie(&amp;quot;account&amp;quot;, secret= ’some-secret-key’)
      if  username:
           return &amp;quot;Hello %s.Welcome back.&amp;quot; % username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然文档上没有但是还有一种操作cookie的方式:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;from bottle import request, response

@route('/login', method=&amp;quot;POST&amp;quot;)
def login():
    user = request.POST['user']
    passwd = request.POST['passwd']

    if check_user_right(user,passwd):
        response.COOKIES['account'] = user
    else:
        pass

@route('/admin')
def admin():
    user = request.COOKIES['user']
    if user:
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是无论我用哪种方式操作我都无法获取cookie,为什么呢.百思不得其解.但是我的一个处理文章点击率的提醒了我,代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;@route('/archrives/:aid#\d+#')
def article_show(aid):
    db = dbconn.ConnDB()
    artid = int(aid)
    # 获取客户端ip
    remoteip = request.environ.get('REMOTE_ADDR')

    artcookie = remoteip+'ip'+aid
    print request.COOKIES.keys()

    # 判断cookie是否存在
    if artcookie in request.COOKIES.keys():
        # 存在则更新有效时间
        response.COOKIES[artcookie] = True
        response.COOKIES[artcookie]['max-age'] = 500
    else:
        # 不存在则更新文章查看次数
        db.posts.update({&amp;quot;id&amp;quot;:artid}, {&amp;quot;$inc&amp;quot;:{&amp;quot;views&amp;quot;:1}})

        # 并设置cookie
        response.COOKIES[artcookie] = True
        response.COOKIES[artcookie]['max-age'] = 500

    TEMPLATE['posts'] = getArtList({&amp;quot;id&amp;quot;:artid})
    TEMPLATE.update(setTempVar())

    return template('article.html', TEMPLATE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是可以正常获取到cookie的,而且代码没有任何区别.唯一的区别就是用户认证是跳转了页面.所以我help了一下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;from bottle import response
help(response.set_cookie)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;help的结果其中有两个参数一个是path,和domain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    :param domain: the domain that is allowed to read the cookie.
      (default: current domain)
    :param path: limits the cookie to a given path (default: current path)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显bottle的cookie默认只在当前路径下能读取的到,所以要别的页面读取到cookie我们的代码须改成如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;from bottle import request, response

@route('/login', method=&amp;quot;POST&amp;quot;)
def login():
    user = request.POST['user']
    passwd = request.POST['passwd']

    if check_user_right(user,passwd):
        response.COOKIES['account'] = user
        response.COOKIES['account']['path'] = '/admin'
    else:
        pass

@route('/admin')
def admin():
    user = request.COOKIES['user']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就能在别的路径下访问我们设定的cookie.&lt;/p&gt;</summary><category term="web"></category><category term="python"></category><category term="cookie"></category><category term="bottle"></category></entry><entry><title>使用beaker让bottle支持session</title><link href="http://www.linuxzen.com/shi-yong-beakerrang-bottlezhi-chi-session.html" rel="alternate"></link><updated>2012-05-26T11:38:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-05-26:shi-yong-beakerrang-bottlezhi-chi-session.html</id><summary type="html">&lt;p&gt;bottle是一个小型web框架,很小只有一个文件,但功能确很强大,学起来也简单,简单和小巧的同时也有很多不足,某些功能支持还不是很完善,比如session.但是也有它自身的好处,我们可以自己或使用别的模块来扩展它,不像django,很强大,但是想要进一步扩展的时候确无从下手.我们可以把非常简单而强大的bottle自己动手将它变得更加强大和完善.&lt;/p&gt;
&lt;p&gt;bottle小巧支持cookie但是不支持session.为了安全起见我们有时候希望使用的session.我们可以使用中间件beaker来扩展bottle,使我们的bottle应用支持session.废话不多说.首先beaker不是内置模块,我们首先来安装它.当然你可以网上下包手动安装,我们使用最简单的:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;easy_install beaker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有easy_install这个命令?google吧,装了之后还是没有,如过时win的话检查环境变量,将Python安装目录下的Scripts目录添加到环境变量.&lt;/p&gt;
&lt;p&gt;安装好后我们如何使用它,下面一段带面是使用的:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
from bottle import route, default_app, run, request
from beaker.middleware import SessionMiddleware

session_opts = {
                'session.type':'file',
                'session.cookei_expires':300,
                'session.data_dir':'./sessions',
                'sessioni.auto':True
                }

@route('/test')
def test():
    s = request.environ.get('beaker.session')
    s['test'] = s.get('test', 0) + 1
    s.save()
    return 'Test conter: %d' % s['test']

app = default_app()
app = SessionMiddleware(app, session_opts)
run(app=app)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这段代码,会提示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Bottle server starting up (using WSGIRefServer())...
Listening on http://127.0.0.1:8080/
Hit Ctrl-C to quit.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在打开浏览器访问&lt;code&gt;http://127.0.0.1:8080/test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不断刷新就会发现数值不断在增大.说明我们的session已经正常工作了&lt;/p&gt;</summary><category term="web"></category><category term="session"></category><category term="python"></category><category term="bottle"></category><category term="beaker"></category></entry><entry><title>用Python写的终端下的翻译工具</title><link href="http://www.linuxzen.com/yong-pythonxie-de-zhong-duan-xia-de-fan-yi-gong-ju.html" rel="alternate"></link><updated>2012-04-23T23:23:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-04-23:yong-pythonxie-de-zhong-duan-xia-de-fan-yi-gong-ju.html</id><summary type="html">&lt;p&gt;为什么写这个程序,为什么不给这个程序配备gui?原因很简单,因为我是一个命令行控,Linux习惯了不习惯了鼠标,总觉得点着不如敲命令快,各位在看这篇文章就说明和本人有相同的爱好.这个用python写的翻译工具是通过google来实现的,由于google返回的数据不是很规范(或者说我没有找到规律),现在前三项能正常显示(源词,翻译结果,和汉语拼音).下面的词性和其他释义可能不同,见谅,望大神可以指点下小弟和帮小弟完善,这里赶紧不尽.&lt;/p&gt;
&lt;p&gt;好了不费话了,下面放代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
# -*-coding:utf8 -*-
'''
#=============================================================================
#     FileName: translate.py
#         Desc: To translate with zh to en or en2zh
#       Author: cold
#        Email: wh_linux@126.com
#     HomePage: http://www.linuxzen.com
#      Version: 0.0.1
#   LastChange: 2012-04-23 23:04:08
#      History:
#=============================================================================
'''

import urllib
import urllib2
from sys import argv,exit
import re

# 显示帮助信息
def helpinfo():
print '''
Usage: pytran {zh2en¦en2zh} content
'''
# 格式化输出
def formatresult(result,srclang):
resu = result.split('[[')
if (srclang=='en2zh' or srclang == 'zh2en'):
firstre = resu[1].replace('[','').replace(']','').split('&amp;quot;')
print '源词:',firstre[3]
print '结果:',firstre[1]
if (srclang=='zh2en'):
piny = firstre[7]
else:
piny = firstre[5]
print '拼音:',piny
if(srclang=='zh2en'):
secresu=resu[2].replace('&amp;quot;','').split('[')
else:
secresu = resu[2].replace('&amp;quot;', '').split('[')
print '词性:',secresu[0].replace(',','')
print '其他释义:'
for i in ''.join(secresu[1].split(']')).split(','):
print i

# 获取命令行参数
try:
srclang = argv[1]
except:
helpinfo()
exit(1)
try:
cont = argv[2]
except:
helpinfo()
exit(2)

# 判断翻译目标语言用来确定传送参数
if(srclang == 'zh2en'):
data=urllib.urlencode({'client':'t', 'text':cont,
'hl':'zh-CN','tl':'en',
'multires':'1','prev':'btn',
'ssel':'0','sc':'1'})
elif(srclang == 'en2zh'):
data=urllib.urlencode({'client':'t', 'text':cont,
'hl':'zh-CN', 'sl':'en','tl':'zh-CN',
'multires':'1', 'prev':'btn',
'ssel':'0','sc':'1'})
else:
helpinfo()

# 打开google翻译内容
url = 'http://translate.google.cn/translate_a/t'
req =urllib2.Request(url,data)
req.add_header(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0+(compatible;+Googlebot/2.1;++http://www.google.com/bot.html)&amp;quot;)
fd = urllib2.urlopen(req)
result =  fd.read()

# 格式化输出
formatresult(result, srclang)
fd.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了更方便的使用我们把这个脚本命名位pytranslate,放到/usr/bin下,并赋予执行权限:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x /usr/bin/pytranslate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就可以使用它进行翻译了:
翻译英文到中文:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pytranslate en2zh extent
源词: extent
结果: 程度
拼音: Chéngdù
词性: 名词
其他释义:
程度
范围
幅度
规模
度
地步
广度
长度
面
长短
份儿
界
en
翻译中文到英文
pytranslate zh2en 中国
源词: 中国
结果: China
拼音: Zhōngguó
词性: 名词
其他释义:
China
zh-CN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧相信聪明的你肯定发现如何使用了这里就不罗嗦了.&lt;/p&gt;</summary><category term="翻译"></category><category term="终端"></category><category term="python"></category><category term="Linux"></category><category term="google"></category></entry><entry><title>用python发带附件的邮件用来定时备份mysql数据库</title><link href="http://www.linuxzen.com/yong-pythonfa-dai-fu-jian-de-you-jian-yong-lai-ding-shi-bei-fen-mysqlshu-ju-ku.html" rel="alternate"></link><updated>2012-04-21T18:26:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-04-21:yong-pythonfa-dai-fu-jian-de-you-jian-yong-lai-ding-shi-bei-fen-mysqlshu-ju-ku.html</id><summary type="html">&lt;p&gt;最近迁移了wordpress,系统升级为CentOS 6,很奇怪的一个问题,在原来CentOS 5.8下用的很正常的定时备份数据库并通过邮件发送的脚本不能发送附件,其他都正常,邮件内容也是uuencode生成的文件编码,但是就是不产生附件.而且找不出原因,望有知道的不吝赐教.&lt;/p&gt;
&lt;p&gt;为了解决这一问题,我用Python写了一个mail客户端,可以发送附件,是一个命令行程序.废话不多说.贴代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/env python
#-*- coding: utf8 -*-
'''
#=============================================================================
#     FileName: mail.py
#         Desc: To send email
#       Author: cold
#        Email: wh_linux@126.com
#     HomePage: http://www.linuxzen.com
#      Version: 0.0.1
#   LastChange: 2012-04-21 16:37:20
#      History:
#=============================================================================
'''

'''
用于发送邮件,可以发送附件
命令行程序
'''
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import sys



# 打印帮助信息
def helpinfo():
    print '''
    Useage: pymail -u user@domain -p passwd -h smtp server host -t to who [-a attachment file path] [-n attachment name]
    Useage: email content use . to end
    -h  specify smtp server host
    -u  which user you login the smtp server,and must with it domain
    -p  the password of the smtp user
    -t  The email recipient,multiple addresses can use ',' split
    -a  Add attachment
    -n  Secify attachment name in the email

    Author:cold(wh_linux@126.com)
    Homepge:http://www.linuxzen.com
    '''


# 所有选项
options = ['-t', '-a', '-n', '-h', '-u', '-p', '-s']

# 获取选项长度
argvnum = len(sys.argv)

# 检测命令行参数
for i in range(argvnum):
    if ( i %2 != 0):
        if (sys.argv[i] not in options):
            print 'Unknow option ', sys.argv[i] , ', Please use -h see help!'
            sys.exit(3)

# 如果是-h或者没有命令行参数则显示帮助
try:
    if sys.argv[1] == '-h' or len(sys.argv) == 0:
        helpinfo()
except:
    helpinfo()


# 检测-n参数
if ('-n' in sys.argv) and ('-a' not in sys.argv):
    print 'Error:option &amp;quot;-n&amp;quot; must use after -a'
    sys.exit(2)

# 下面则是获取各个参数内容
try:
    tmpmailto = sys.argv[sys.argv.index('-t')  + 1]
    if ',' in tmpmailto:
        mailto = tmpmailto.split(',')
    else:
        mailto = [tmpmailto,]
except ValueError:
    print 'Error: need Mail Recipient'
    sys.exit(1)

haveattr=True

try:
    attrpath = sys.argv[sys.argv.index('-a') + 1]
    try:
        attrname = sys.argv[sys.argv.index('-n') +1 ]
    except ValueError:
        attrname = attrpath.split('/')[-1]
except:
    attrname = None
    haveattr = False
    attrpath = None


try:
    mail_host = sys.argv[sys.argv.index('-h') +1]
except ValueError:
    print 'Waring: No specify smtp server use 127.0.0.1'
    mail_host = '127.0.0.1'


try:
    mail_useremail = sys.argv[sys.argv.index('-u') +1]
except ValueError:
    print 'Waring: No specify user, use root'
    mail_useremail = 'root@localhost'

try:
    mail_sub = sys.argv[sys.argv.index('-s') + 1]
except:
    mail_sub = 'No Subject'

mail_user = mail_useremail.split('@')[0]
mail_postfix = mail_useremail.split('@')[1]

try:
    mail_pass = sys.argv[sys.argv.index('-p') +1]
except ValueError:
    mail_pass = ''




# 定义邮件发送函数
def send_mail(to_list, sub, content, haveattr, attrpath, attrname):
    me = mail_user + &amp;quot;&amp;lt;&amp;quot; + mail_user+&amp;quot;@&amp;quot;+mail_postfix +&amp;quot;&amp;gt;&amp;quot;

    # 判断是否有附件
    if (haveattr):
        if (not attrpath):
            print 'Error : no input file of attachments'
            return False

        # 有附件则创建一个带附件的实例
        msg = MIMEMultipart()

        # 构造附件
        att = MIMEText(open(attrpath, 'rb').read(),'base64', 'utf8')
        att[&amp;quot;Content-Type&amp;quot;] = 'application/octest-stream'
        att[&amp;quot;Content-Disposition&amp;quot;] = 'attachment;filename=&amp;quot;'+ attrname +'&amp;quot;'
        msg.attach(att)
        msg.attach(MIMEText(content))
    else:
        # 无责创建一个文本的实例
        msg = MIMEText(content)


    # 邮件头
    msg['Subject'] = sub
    msg['From'] = me
    msg['To'] = &amp;quot;;&amp;quot;.join(to_list)
    try:
        # 发送邮件
        s = smtplib.SMTP()
        s.connect(mail_host)
        if (mail_host != '127.0.0.1'):
            s.login(mail_user, mail_pass)
        s.sendmail(me, to_list, msg.as_string())
        s.close()
        return True
    except Exception, e:
        print str(e)
        return False

if __name__ == '__main__':

    try:
        content = ''
        while True:
            c = raw_input('')
            if c == '.':
                break
            content += c + '\n'
    except EOFError:
        for line in sys.stdin:
            content += line
    if send_mail(mailto, mail_sub, content, haveattr, attrpath, attrname):
        print &amp;quot;Success&amp;quot;
    else:
        print &amp;quot;Failed&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将这个脚本保存为pymail放到/usr/bin/下,并赋予其执行权限:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x /usr/bin/pymail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用 -h指定smtp发件服务器,默认认为指定-h需要认证, 所以就需要smtp服务器支持认证,同时需要-u指定用户名(需加"@域名"),-p指定密码.
如果不指定-h就会使用本地smtp服务器,默认不需要认证,所以本地的smtp服务器就不能支持认证,同时不需指定-u,-p参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-t 指定收件人多个可用,号分割.
-a 指定附件路径
-n 指定附件名(可省略)
-h 显示帮助信息.
-s 指定邮件主题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后会要求输入邮件内容,写完用.结束
也可以用管道下面给出几个实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;#使用本地smtp服务发送
echo 'linuxzen.com backup' | pymail -s &amp;quot;Linuxzen backup&amp;quot; -t 123456@qq.com -a /tmp/linuxzen.tar.gz
# 使用126邮箱发送
echo 'linuxzen.com backup' | pymail -u linuxzen@126.com -p linuxzen.com -h smtp.126.com -s 'Linuxzen backup &amp;quot; -t 123456@qq.com -a /tmp/linuxzen.tar.gz 

# 不使用管道发送
pymail -u linuxzen@126.com -p linuxzen.com -h smtp.126.com -s 'hello world' -t 123456@qq.com -a /tmp/linuxzen.tar.gz
Hello
this is a test mail
.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面之前使用的mysql定时备份的脚本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
export PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
DATE=`date +%Y%m%d`
mysqldump -u root blogdata &amp;gt; /tmp/blogdate.&amp;quot;$DATE&amp;quot;.sql
cd /tmp
tar -zcf blogdata.&amp;quot;$DATE&amp;quot;.sql.tar.gz blogdata.&amp;quot;$DATE&amp;quot;.sql
uuencode blogdata.&amp;quot;$DATE&amp;quot;.sql.tar.gz blogdata.&amp;quot;$DATE&amp;quot;.sql.tar.gz | mail -s 'MySQL Backup' 123456@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有命令uuencode安装sharutils包即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum -y install sharutils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用crontab调用这个脚本定时执行,前面说了 这个脚本在CentOS5.x下正常工作,但是放到CentOS6下就不带附件,所以使用我们自己编写的python脚本脚本内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
export PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
DATE=`date +%Y%m%d`
mysqldump -u root blogdata &amp;gt; /tmp/myblog.&amp;quot;$DATE&amp;quot;.sql
cd /tmp
tar -zcf blogdata.&amp;quot;$DATE&amp;quot;.sql.tar.gz myblog.&amp;quot;$DATE&amp;quot;.sql
echo 'MySQL backup' | pymail -u linuzen@126.com -p linuxzen.com -h smtp.126.com -s 'MySQL backup' -a /tmp/blogdata.&amp;quot;$DATE&amp;quot;.sql.tar.gz -t 123456@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用126邮箱来发送 这样就可以把自带的sendmail 停掉:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service sendmail stop
chkonfig --del sendmail
&lt;/code&gt;&lt;/pre&gt;</summary><category term="附件"></category><category term="邮件"></category><category term="定时"></category><category term="备份"></category><category term="python"></category><category term="pymail"></category><category term="MySQL"></category><category term="mail"></category></entry><entry><title>使用Python进行web开发</title><link href="http://www.linuxzen.com/shi-yong-pythonjin-xing-webkai-fa.html" rel="alternate"></link><updated>2012-04-13T16:39:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-04-13:shi-yong-pythonjin-xing-webkai-fa.html</id><summary type="html">&lt;p&gt;最近有一个小的web项目,想用喜爱都python,但是想到之前接触过都django我感觉一阵不寒而栗,为什么?Django的配置太过复杂,而且小项目不太适合MVC的开发模式,所以我将目光转向了web.py这个小型web框架,并且真正让我动心都是其官方网站上都一句话:"Django lets you write web apps in Django. TurboGears lets you write web apps in TurboGears. Web.py lets you write web apps in Python." —  Adam Atlas&lt;/p&gt;
&lt;p&gt;最近切换了Ubuntu替换了Win7系统,所以这里介绍下Ubuntu都安装web.py&lt;/p&gt;
&lt;h3&gt;安装easy_install&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install python-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用easy_install安装web.py&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo easy_install web.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;测试是否安装成功:&lt;/h3&gt;
&lt;p&gt;在python shell中执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有报错则web.py安装成功.
下面开始我们第一个hello,world&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;import web

urls = (&amp;quot;/.*&amp;quot;, &amp;quot;hello&amp;quot;)                # 指定任何url都指向hello类
app = web.application(urls, globals()) # 绑定url

# 定义相应类
class hello:
def GET(self):
return 'Hello, world!'

if __name__ == &amp;quot;__main__&amp;quot;:
app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后保存为&lt;code&gt;hello.py&lt;/code&gt;并运行它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python hello.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会看到输出:http://0.0.0.0:8080/&lt;/p&gt;
&lt;p&gt;然后浏览器访问:http://localhost:8080即可看到
&lt;code&gt;Hello, world!&lt;/code&gt;
我们第一个用python写的web程序就建立完成.&lt;/p&gt;</summary><category term="开发"></category><category term="web.py"></category><category term="Ubuntu"></category><category term="python"></category><category term="Linux"></category></entry></feed>