<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>cold's world</title><link href="http://www.linuxzen.com/" rel="alternate"></link><link href="http://www.linuxzen.com/feeds/vim.atom.xml" rel="self"></link><id>http://www.linuxzen.com/</id><updated>2013-01-05T15:01:00+08:00</updated><entry><title>Vim配置系列(二) —- 好看的statusline</title><link href="http://www.linuxzen.com/vimpei-zhi-xi-lie-er-hao-kan-de-statusline.html" rel="alternate"></link><updated>2013-01-05T15:01:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-01-05:vimpei-zhi-xi-lie-er-hao-kan-de-statusline.html</id><summary type="html">&lt;p&gt;Vim是一款文本编辑器,但是这并不影响它有一个好看的外观,大家都知道Vim可以通过配色方案来改变Vim的外观,满足一些"好色之徒",之前大家可能也主意到截图中一个非常漂亮的statusline,这是通过Vim的一个Powerline的插件实现的.之前我们配置了Vundle的插件管理(传送门)我们可以用Vundle安装Powerline,在.vimrc(Windows可能是_vimrc)中添加:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;Bundle &amp;quot;Lokaltog/vim-powerline&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重新打开vim执行&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;:BundleInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你和github畅通的话就会顺利安装插件,然后在.vimrc里添加&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;set laststatus=2
let g:Powerline_symbols='unicode'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果gvim打开需要使用/path/to/your/bundle/vim-powerline/fontpatcher/fontpatcher给当前gvim使用的字体打上补丁(依赖需要fontforge和python)&lt;/p&gt;
&lt;p&gt;然后重新打开vim你就会发现一个漂亮的statusline&lt;/p&gt;
&lt;p&gt;&lt;img alt="好看的statusline" src="/upload/VimPythonComment1.png" /&gt;&lt;/p&gt;</summary><category term="配置"></category><category term="系列"></category><category term="漂亮"></category><category term="插件"></category><category term="vim"></category><category term="statusline"></category><category term="Powerline"></category></entry><entry><title>Vim 结合Python编写的翻译插件</title><link href="http://www.linuxzen.com/vim-jie-he-pythonbian-xie-de-fan-yi-cha-jian.html" rel="alternate"></link><updated>2013-01-04T17:58:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2013-01-04:vim-jie-he-pythonbian-xie-de-fan-yi-cha-jian.html</id><summary type="html">&lt;p&gt;最近重写了一下之前用Python写的一个终端翻译工具,想着Vim7.3 支持Python于是想将这个功能写为一个插件让Vim也支持翻译功能,现在英汉翻译比较完善, &lt;Leader&gt;t会翻译光标下单词,选中的翻译还不完善,仅仅是个半成品,在此抛砖引玉.将下面代码复制保存为translate.vim 放到~/.vim/plugin目录下即可,代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;&amp;quot;   Author  :   cold
&amp;quot;   E-mail  :   wh_linux@126.com
&amp;quot;   Date    :   2012/12/20 16:23
&amp;quot;   Desc    :   英汉/汉英翻译插件
&amp;quot;   Useage  :
&amp;quot;                  &amp;lt;Leader&amp;gt; t 翻译当前光标下内容 //XXX 中文不行
&amp;quot;                  &amp;lt;Leader&amp;gt; lt 翻译当前行
&amp;quot;                  &amp;lt;Leader&amp;gt; vt 翻译选中的内容

function GetCursorWord()
    let column = get(getpos('.'), 2, 0) - 1
    let line = getline('.')
    let word = strpart(line, column, 1)
    let start = 1
    while 1
        let tmp = strpart(line, column + start, 1)
        if tmp =~ &amp;quot;[a-zA-Z]&amp;quot;
            let word = word . tmp
        else
            break
        endif
        let start = start + 1
    endwhile
    let start = 1
    while 1
        let tmp = strpart(line, column - start, 1)
        if tmp =~ '[a-zA-Z]'
            let word = tmp . word
        else
            break
        endif
        let start = start + 1
    endwhile
    return word
endfunc

function Translate(m)
    &amp;quot; m 1 -&amp;gt; 翻译当前行
    &amp;quot; m 2 -&amp;gt; 翻译选中
    if mode() == 'n'
        let word = GetCursorWord() &amp;quot; 如果是命令模式则取当前字符下单词
    endif
    &amp;quot;XXX Visual 模式mode()命令返回n
    if a:m == 2
        let word = getreg('*')     &amp;quot; 如果是选择模式获取选择块

    endif
    if a:m == 1
        let word = getline('.')
    endif
python &amp;lt;&amp;lt; EOF

import vim
import urllib
import urllib2

class Translate(object):
    &amp;quot;&amp;quot;&amp;quot; 使用google进行英-&amp;gt;汉, 汉-&amp;gt;英的翻译 &amp;quot;&amp;quot;&amp;quot;
    def __init__(self, text, src='zh-CN', dst = 'en'):
        self.url = 'http://translate.google.cn/translate_a/t'
        self.params = dict(client = &amp;quot;t&amp;quot;, text=text,
                           hl = 'zh-CN', tl = dst,
                           multires = '1', prev = 'btn',
                           ssel = '0', sc = '1')
        if src != self.params.get('hl'):
            self.params.update(sl = src)

        return

    def loads(self, content):
        &amp;quot;&amp;quot;&amp;quot; 加载翻译结果 &amp;quot;&amp;quot;&amp;quot;
        while ',,' in content or '[,' in content:
            content = content.replace(',,', ',&amp;quot;&amp;quot;,')
            content = content.replace('[,', '[&amp;quot;&amp;quot;,')
            #content = content.replace(',]', '&amp;quot;&amp;quot;,]')
        content = eval(content)
        result = content[0][0]
        desc = content[1]
        pinyin = result[2] if result[2] else result[3]
        others = ''
        for d in desc:
            others += d[0] + '\n'
            for i in d[1]:
                others += &amp;quot;\t{0}\t&amp;quot;.format(i)
                for s in d[2]:
                    if s[0] == i:
                        others +=','.join(s[1]) + '\n'
        r = dict(
            result = result[0],
            source = result[1],
            pinyin = pinyin,
        )
        return r

    def translate(self):
        &amp;quot;&amp;quot;&amp;quot; 调用google翻译 &amp;quot;&amp;quot;&amp;quot;
        params = urllib.urlencode(self.params)
        req = urllib2.Request(self.url, params)
        req.add_header(&amp;quot;User-Agent&amp;quot;,
                       &amp;quot;Mozilla/5.0+(compatible;+Googlebot/2.1;&amp;quot;
                       &amp;quot;++http://www.google.com/bot.html)&amp;quot;)

        res = urllib2.urlopen(req)
        result =  res.read()
        return self.loads(result)

def auto_translate(text):
    &amp;quot;&amp;quot;&amp;quot; 自动检测当前语言进行翻译 &amp;quot;&amp;quot;&amp;quot;
    text = text.decode('utf-8')
    if text[0] &amp;gt; u'z':
        src = 'zh-CN'
        dst = 'en'
    else:
        src = 'en'
        dst = 'zh-CN'
    t = Translate(text.encode('utf-8'), src, dst)
    result = t.translate()
    return result

word = vim.eval('word')
result = auto_translate(word.strip())
vim.command('echo &amp;quot;源词: ' + result.get(&amp;quot;source&amp;quot;) + '&amp;quot;')
vim.command('echo &amp;quot;结果: ' + result.get(&amp;quot;result&amp;quot;) + '&amp;quot;')
vim.command('echo &amp;quot;拼音: ' + result.get(&amp;quot;pinyin&amp;quot;) + '&amp;quot;')
if result.get('others'):
    vim.command('echo &amp;quot;其他释义: &amp;quot;')
    vim.command('echo &amp;quot;' + result.get('others') + '&amp;quot;')

EOF

endfunc
nmap &amp;lt;Leader&amp;gt;t :call Translate(0)&amp;lt;cr&amp;gt;
nmap &amp;lt;Leader&amp;gt;lt :call Translate(1)&amp;lt;cr&amp;gt;
&amp;quot;XXX 无法判断当前模式,使用映射替代
map &amp;lt;Leader&amp;gt;ts :call Translate(2)&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary><category term="翻译"></category><category term="插件"></category><category term="vim"></category><category term="python"></category></entry><entry><title>Vim配置系列(一) ---- 插件管理</title><link href="http://www.linuxzen.com/vimpei-zhi-xi-lie-cha-jian-guan-li.html" rel="alternate"></link><updated>2012-12-14T08:57:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-12-14:vimpei-zhi-xi-lie-cha-jian-guan-li.html</id><summary type="html">&lt;p&gt;最近对Vim进行了一番较大的配置变动,所以就想写出一个系列来将配置过程分享下来,供需要的朋友参考.我们之前配置Vim插件是一大助力,可以帮助我们做一些比较cool或这比较实用的功能,但是我之前都是直接搜索插件然后下载下来,手动拷贝到相应的插件,这种感觉肯定是不爽,不管是Linux还是Python/Ruby都有一套自己的包管理器,可以比较智能的搜索/安装/升级/卸载包.Vim也有类似功能的插件Vundle,他是一款Vim插件管理器,依赖于git,git是一款非常棒的VCS这里不做介绍,有兴趣的可以了解一下.Vundle可以根据配置文件的github或其他git的路径自行安装/升级插件.下面我们来介绍如何安装:
首先在你的~/.vim下或者$VIM/vimfiles($VIM是vim的安装路径)创建bundle目录&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;mkdir ~/.vim/bundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用git克隆Vundle项目:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的.vimrc里添加下面内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;set nocompatible
filetype off                              &amp;quot; 先关闭文件类型
set rtp+=~/.vim/bundle/vundle             &amp;quot; 将vundle路径添加到插件vim路径
call vundle#rc()                          &amp;quot; 执行Vundle初始化
Bundle 'gmarik/vundle'                    &amp;quot; 将Vundle加入到bundle

filetype indent plugin on                 &amp;quot; 安装完后打开文件类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如需加上插件则在Bundle 'gmarik/vundle'后加上相应的Bundle,如果是github则可以只输入后面的相对路径,如果是其他git则需输入全部url,下面给出一个完整的例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;set nocompatible
filetype off
set rtp+=~/.vim/bundle/vundle
call vundle#rc()
Bundle 'gmarik/vundle'
&amp;quot;Bundle &amp;quot;MarcWeber/vim-addon-mw-utils&amp;quot;
&amp;quot;Bundle &amp;quot;tomtom/tlib_vim&amp;quot;
&amp;quot;Bundle &amp;quot;honza/snipmate-snippets&amp;quot;
&amp;quot;Bundle &amp;quot;garbas/vim-snipmate&amp;quot;
Bundle &amp;quot;Shougo/neocomplcache&amp;quot;
Bundle &amp;quot;Lokaltog/vim-powerline&amp;quot;
Bundle &amp;quot;drakeguan/vim-vcscommand&amp;quot;
Bundle &amp;quot;scrooloose/nerdtree&amp;quot;
Bundle &amp;quot;pix/vim-taglist&amp;quot;
Bundle &amp;quot;nathanaelkane/vim-indent-guides&amp;quot;
Bundle &amp;quot;clones/vim-cecutil&amp;quot;
Bundle &amp;quot;tpope/vim-fugitive&amp;quot;
&amp;quot;Bundle &amp;quot;c9s/bufexplorer&amp;quot;
Bundle &amp;quot;jnwhiteh/vim-golang&amp;quot;
Bundle &amp;quot;kevinw/pyflakes-vim&amp;quot;
Bundle &amp;quot;mbriggs/mark.vim&amp;quot;
&amp;quot;Bundle &amp;quot;vim-scripts/TabBar&amp;quot;
Bundle &amp;quot;vim-scripts/DrawIt&amp;quot;
Bundle &amp;quot;vim-scripts/calendar.vim--Matsumoto&amp;quot;
Bundle &amp;quot;vim-scripts/Python-mode-klen&amp;quot;
&amp;quot;Bundle &amp;quot;vim-scripts/pydoc.vim&amp;quot;
Bundle &amp;quot;vim-scripts/VOoM&amp;quot;
Bundle &amp;quot;vim-scripts/qiushibaike&amp;quot;
Bundle &amp;quot;vim-scripts/AuthorInfo&amp;quot;
Bundle &amp;quot;vim-scripts/javacomplete&amp;quot;
Bundle &amp;quot;vim-scripts/javaDoc.vim&amp;quot;
Bundle &amp;quot;drmingdrmer/xptemplate.git&amp;quot;
Bundle &amp;quot;vim-scripts/Java-Syntax-and-Folding&amp;quot;

filetype indent plugin on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是我的Vundle配置,再后面的文章会对其中一些做出介绍:&lt;/p&gt;
&lt;p&gt;配置完后保存使用Vim打开任意文档执行&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;:BundleInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果网络通畅Bundle会逐个安装每个插件.&lt;/p&gt;
&lt;p&gt;同时还有:BundleSearch用于搜索插件,非常方便.&lt;/p&gt;</summary><category term="配置"></category><category term="系列"></category><category term="管理"></category><category term="插件"></category><category term="Vundle"></category><category term="vim"></category><category term="Bundle"></category></entry><entry><title>Vim打开Python源码自动添加#!行和编码行 升级版</title><link href="http://www.linuxzen.com/vimda-kai-pythonyuan-ma-zi-dong-tian-jia-xing-he-bian-ma-xing-sheng-ji-ban.html" rel="alternate"></link><updated>2012-12-13T14:31:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-12-13:vimda-kai-pythonyuan-ma-zi-dong-tian-jia-xing-he-bian-ma-xing-sheng-ji-ban.html</id><summary type="html">&lt;p&gt;之前给大家分享过一个打开Python源代码时自动添加#!行和编码行来避免一些重复的工作,那个是因为需要大量编写时临时的解决方案,后来使用中会出现一些问题,比如查看别人源码时也会更改一些东西,从而造成git不必要的更新和手动删除的额外动作,所以又写了一个,只是在文件是新打开文件时或者空文件才自动添加的方法,同时再打开python源文件将这个方法绑定要F4上可以手动添加,并会判断是否有这两行,如果有则不执行动作,同时也添加了一些辅助性注释, 比如 作者/邮箱/创建日期和描述,代码实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;&amp;quot;Python 注释
function InsertPythonComment()
    exe 'normal'.1.'G'
    let line = getline('.')
    if line =~ '^#!.*$' || line =~ '^#.*coding:.*$'
        return
    endif
    normal O
    call setline('.', '#!/usr/bin/env python')
    normal o
    call setline('.', '# -*- coding:utf-8 -*-')
    normal o
    call setline('.', '#')
    normal o
    call setline('.', '#   Author  :   '.g:python_author)
    normal o
    call setline('.', '#   E-mail  :   '.g:python_email)
    normal o
    call setline('.', '#   Date    :   '.strftime(&amp;quot;%y/%m/%d %H:%M:%S&amp;quot;))
    normal o
    call setline('.', '#   Desc    :   ')
    normal o
    call setline('.', '#')
    normal o
    call cursor(7, 17)
endfunction
function InsertCommentWhenOpen()
    if a:lastline == 1 &amp;amp;&amp;amp; !getline('.')
        call InsertPythonComment()
    end
endfunc
au FileType python :%call InsertCommentWhenOpen()
au FileType python map &amp;lt;F4&amp;gt; :call InsertPythonComment()&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将上面的代码放到你的vimrc中,同时在vimrc添加:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;let g:python_author = 'cold'               # 姓名
let g:python_email  = 'wh_linux@126.com'   # 邮箱
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在每次打开空的python源文件时就会添加这些注释信息,并可以在非空没有这些注释的情况下按F4添加,配置玩后,打开空的python源文件效果如下:
&lt;img alt="好看的statusline" src="/upload/VimPythonComment1.png" /&gt;&lt;/p&gt;</summary><category term="自动"></category><category term="编码信息"></category><category term="添加"></category><category term="vim"></category><category term="shbang line"></category><category term="python"></category></entry><entry><title>用Vim为Python源码自动添加#!行和编码行</title><link href="http://www.linuxzen.com/yong-vimwei-pythonyuan-ma-zi-dong-tian-jia-xing-he-bian-ma-xing.html" rel="alternate"></link><updated>2012-09-29T18:56:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-09-29:yong-vimwei-pythonyuan-ma-zi-dong-tian-jia-xing-he-bian-ma-xing.html</id><summary type="html">&lt;p&gt;每次开始写Python打开文件第一件事就是写上&lt;code&gt;#!/usr/bin/env python和&lt;/code&gt;编码之类的东西,&lt;/p&gt;
&lt;p&gt;太多了,写烦就,写了一个打开Python自动填充的函数,将下面内容添加到&lt;code&gt;~/.vimrc&lt;/code&gt;下即可每次打开如果没有上述行则会自动填充:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;function InsertPythonHeader()
    let l1 = getline(1)
    let l2 = getline(2)
    if  match('\#!/', l1) == 0
        exec 1
        normal O
        call setline(1,'#!/usr/bin/env python')
    endif
    if match(&amp;quot;\#&amp;quot;, l2) == 0 &amp;amp;&amp;amp; (match(&amp;quot;-&amp;quot;, l2)  != 2 ¦¦ (match(&amp;quot;code&amp;quot;, l2) != 2))
        exec 2
        normal O
        call setline(2,'#-*- coding:utf-8 -*-')
    endif
endfunction

au FileType python call InsertPythonHeader()
&lt;/code&gt;&lt;/pre&gt;</summary><category term="自动"></category><category term="编码信息"></category><category term="添加"></category><category term="vim"></category><category term="shbang line"></category><category term="python"></category></entry><entry><title>分享Vim两种好用的功能:状态行和空白字符可见</title><link href="http://www.linuxzen.com/fen-xiang-vimliang-chong-hao-yong-de-gong-neng-zhuang-tai-xing-he-kong-bai-zi-fu-ke-jian.html" rel="alternate"></link><updated>2012-09-29T17:30:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-09-29:fen-xiang-vimliang-chong-hao-yong-de-gong-neng-zhuang-tai-xing-he-kong-bai-zi-fu-ke-jian.html</id><summary type="html">&lt;p&gt;马上要放假了,没事折腾了一下Vim发现了两个非常棒的功能,一个是给Vim添加一个状态栏,一个是可以在编辑的时候显示空白,&lt;/p&gt;
&lt;p&gt;我的状态栏显示了:
正在编辑的文件名,
选项
是Git显示git分支(需要fugitive插件)
文件类型
当前目录
当前字符的ASCII和16进制码
右边是当前光标所在行/列,文件的位置的百分比,和文件的长度
fugitive 可以在git获得:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone http://github.com/tpope/vim-fugitive.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将plugin目录下的fugitive.vim复制到~/.vim/plugin下
在~/.vimrc添加如下内容&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;if has('statusline')
    set laststatus=2
    set statusline=%&amp;lt;%f\   &amp;quot; 文件名
    set statusline+=%w%h%m%r &amp;quot; 选项
    set statusline+=%{fugitive#statusline()} &amp;quot;Git
    set statusline+=\ [%{&amp;amp;ff}/%Y]            &amp;quot; filetype
    set statusline+=\ [%{getcwd()}]          &amp;quot; current dir
    set statusline+=\ [A=\%03.3b/H=\%02.2B] &amp;quot; ASCII / Hexadecimal value of char
    set statusline+=%=%-14.(%l,%c%V%)\ %p%%\ %L  &amp;quot; Right aligned file nav info
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要想在编辑时将空白可见可以在.vimrc中添加如下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;set listchars=tab:&amp;gt;-,trail:-,extends:#,nbsp:-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可tab显示为&amp;gt;---,空格显示-,行尾的空白显示-,&lt;/p&gt;
&lt;p&gt;设置完后非常的cool,上图一张:
&lt;img alt="vim空白符" src="/upload/Screenshot-2012-09-29-173517.png" /&gt;&lt;/p&gt;</summary><category term="空白"></category><category term="字符"></category><category term="可见"></category><category term="vim"></category><category term="statusline"></category></entry><entry><title>Linux下配置vim一键编译C/C++并执行</title><link href="http://www.linuxzen.com/linuxxia-pei-zhi-vim-jian-bian-yi-ccbing-zhi-xing.html" rel="alternate"></link><updated>2012-04-05T12:07:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2012-04-05:linuxxia-pei-zhi-vim-jian-bian-yi-ccbing-zhi-xing.html</id><summary type="html">&lt;p&gt;最近在学习C++,编辑器当然是vim,想在编辑的时候可以一键编译,于是自己写了一个小脚本配合vim来实现.由于刚开始学,所以对C/C++的扩展名不太了解,所以只对.cpp .cc .c进行处理.&lt;/p&gt;
&lt;p&gt;首先在/usr/bin/下创建compile脚本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi /usr/bin/compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加如下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;#!/bin/bash
# Filename : compile
# Describe : To compile c/c++
# Author   : cold night(www.linuxzen.com)
# Version  : 0.2
# Change   : 增加终端着色 

clear
if [ $# -eq 1 ]
then
    filename=$1
    outname=${filename%\.*}
    typename=${filename#*\.}
    if ( test &amp;quot;$typename&amp;quot; = &amp;quot;cpp&amp;quot; || &amp;quot;$typename&amp;quot; = &amp;quot;cc&amp;quot; )
    then
        echo -n &amp;quot;Compiling...&amp;quot;
        g++ -o &amp;quot;$outname&amp;quot; &amp;quot;$filename&amp;quot; 2&amp;gt; /tmp/errinfo &amp;gt;&amp;amp;2
        if [ $? -eq 0 ]
        then
            echo -e &amp;quot;       \033[32;1mSuccess!!!\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            echo -e &amp;quot;\033[1;44mRunning...\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            ./&amp;quot;$outname&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
        else
            echo -e &amp;quot;       \033[1;31mError!!!\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            echo -e &amp;quot;\033[1;44mError Info:\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            cat /tmp/errinfo
            echo &amp;quot;------------------------&amp;quot;
        fi

    elif [ &amp;quot;$typename&amp;quot; = &amp;quot;c&amp;quot; ]
    then
        echo &amp;quot;Compiling...&amp;quot;
        echo &amp;quot;------------------------&amp;quot;
        gcc -o &amp;quot;$outname&amp;quot; &amp;quot;$filename&amp;quot; 2&amp;gt;/tmp/errinfo &amp;gt;&amp;amp;2
        if [ $? -eq 0 ]
        then
            echo -e &amp;quot;       \033[32;1mSuccess!!!\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            echo -e &amp;quot;\033[1;44mRunning...\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            ./&amp;quot;$outname&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
        else
            echo -e &amp;quot;       \033[1;31mError!!!\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            echo -e &amp;quot;\033[1;44mError Info:\033[0m&amp;quot;
            echo &amp;quot;------------------------&amp;quot;
            cat /tmp/errinfo
            echo &amp;quot;------------------------&amp;quot;
        fi

    fi
else
    echo 'Error: No intput filename'
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后给脚本赋予执行权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x /usr/bin/compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编辑vim配置文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加下面内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class="vim"&gt;&amp;quot; C++ complier
autocmd FileType cpp map &amp;lt;F8&amp;gt; &amp;lt;Esc&amp;gt;:w!&amp;lt;CR&amp;gt;:!compile %&amp;lt;CR&amp;gt;
autocmd FileType cc map &amp;lt;F8&amp;gt; &amp;lt;Esc&amp;gt;:w!&amp;lt;CR&amp;gt;:!compile %&amp;lt;CR&amp;gt;
autocmd FileType c map &amp;lt;F8&amp;gt; &amp;lt;Esc&amp;gt;:w!&amp;lt;CR&amp;gt;:!compile %&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完毕我们就可以用vim编辑C/C++源文件的时候按F8就可以进行一键编译执行.&lt;/p&gt;</summary><category term="编译"></category><category term="一键"></category><category term="vim"></category><category term="Linux"></category><category term="C/C++"></category></entry></feed>